<?xml version="1.0" encoding="UTF-8"?>
 
	<chapter>
		<title>Application hook-ups
</title>
		<sect1>
			<title>Introduction
</title>
			<para>It would be neither possible nor useful to create a system which has a solution, for every problem or requirement which could appear during the development-process (and life-cycle) of a database application.
</para>
			<para>Because it is impossible to foresee all eventual use cases and user needs, an 'all-in-one' product would most likely restrict the application developer sooner or later.
</para>
			<para>In order to handle the all-to-familiar unknown, systems must offer a kind of programming facility or Application Programmer Interface. DbForms offers the following:
</para>
		</sect1>
		<sect1>
			<title>Interface DbEventInterceptor
</title>
			<para>DbForms provides the <computeroutput>DbEventInterceptor</computeroutput> interface, which is capable of intercepting database operations (before and after they are executed).
</para>
			<para>This interface provides the following methods
</para>
			<example>
				<title>Listing 26  methods defined in interface DbEventInterceptor
</title>
				<programlisting>public int preInsert(HttpServletRequest request, Hashtable fieldValues, DbFormsConfig
config, <emphasis role="bold">Connection</emphasis> con)
 
		throws ValidationException;
 
		public void postInsert(HttpServletRequest request, DbFormsConfig config, Connection con);
 
		public int <emphasis role="bold">preUpdate</emphasis>(HttpServletRequest request, <emphasis role="bold">Hashtable</emphasis> fieldValues, <emphasis role="bold">DbFormsConfig</emphasis> 
		config, <emphasis role="bold">Connection</emphasis> con)
 
		throws ValidationException;;
 
		public void postUpdate(HttpServletRequest request, DbFormsConfig config, Connection con);
 
		public int preDelete(HttpServletRequest request, Hashtable fieldValues,DbFormsConfig
 
		config, <emphasis role="bold">Connection</emphasis> con)
 
		throws ValidationException;;
 
		public void postDelete(HttpServletRequest request, DbFormsConfig config, Connection con);
 
		public int preSelect(HttpServletRequest request, DbFormsConfig config, Connection con)
 
		throws ValidationException;;
 
		public void postSelect(HttpServletRequest request, DbFormsConfig config, Connection con);
 
		</programlisting>
			</example>
			<para>As the names indicate, the preXxx() methods get called <emphasis role="bold">before</emphasis> the respective database operation is performed, the postXxx() methods get called <emphasis role="bold">after</emphasis> the operation has finished.
</para>
			<para>preXxx methods return a value indicating if the operation should be performed or not
</para>
			<para>
				<computeroutput>DbEventInterceptor</computeroutput>.<computeroutput>GRANT</computeroutput>_<computeroutput>OPERATION</computeroutput>
			</para>
			<para>
				<computeroutput>DbEventInterceptor</computeroutput>.<computeroutput>DENY_OPERATION</computeroutput>
			</para>
			<para>postXxx methods do not return a value, as the operation has already completed.
</para>
		</sect1>
		<sect1>
			<title>Class Diagram
</title>
			<para/>
			<para>
				<figure>
					<title>Figure 21  UML diagram of the DbEventInterceptor interface and some of its implementations
</title>
					<graphic fileref="21" format="GIF"/>
				</figure>
			</para>
			<para>As you can see, there exists an interface <computeroutput>DbEventInterceptor</computeroutput> as described above. Additionally there exists a built-in implementation class <computeroutput>DbEventInterceptorSupport</computeroutput> of this interface. This is a convenience class which allows the developer to override just the methods he/she is interested in. There is no other difference between these two entities.
</para>
		</sect1>
		<sect1>
			<title>Method parameters
</title>
			<para/>
			<para>
				<table>
					<title/>
					<tgroup cols="2">
						<tbody>
							<row>
								<entry>Parameter
</entry>
								<entry>Description</entry>
							</row>
							<row>
								<entry>Connection con</entry>
								<entry>a database connection
=&gt; this object makes it easy to "trigger" other functionality like database-logging, keep up special data constraints, execute a sub-query, etc.</entry>
							</row>
							<row>
								<entry>DbFormsConfig config
</entry>
								<entry>a config object
provides the  method DbFormsConfig.getServletContext() which gives access to other J2EE-resources which may be stored in application scope. This could be an entry point to any other application, including EJB-Apps, Struts-Apps, Messaging systems, etc.
</entry>
							</row>
							<row>
								<entry>HttpServletRequest request
</entry>
								<entry>an http-request object
gives access to various types of information, including the current users name and users groups/roles.
</entry>
							</row>
							<row>
								<entry>Hashtable fieldValues:
</entry>
								<entry>in the preInsert(), preUpdate() and preDelete()-methods:
hashtable which gives access to the fields contained in the current (selected) row.
As the example below will demonstrate:
(String) fieldValues.get("lastname");
will return the field value of the field lastName of the row DbForm's is about to insert, to update or to delete.
In preInsert() and preUpdate() any changes to this hashtable are automatically reflected in the database. This means that the expression:
fieldValues.put("lastname", smith);
will ensure that the value smith be stored in the lastname field in the database. (column lastname must exist!)
</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>Table 5  parameters available in the methods of DbEventInterceptor
</para>
		</sect1>
		<sect1>
			<title>Installing Interceptors
</title>
			<para>How do we tell DbForms <emphasis role="italic">when</emphasis> to invoke <emphasis role="italic">which</emphasis> Interface implementation?
</para>
			<para>This information is provided in the dbForms XML configuration file. Similar to the granted-privileges security-constraint, (described in the security chapter) the XML tag which defines an Interceptor has to be placed inside a &lt;table&gt; element.
</para>
			<example>
				<title/>
				<programlisting>&lt;table name="customer"&gt;&lt;field name="id" fieldType="int" isKey="true"/&gt; 
		&lt;field name="firstname" fieldType="char" /&gt; 
		&lt;field name="lastname" fieldType="char" /&gt; 
		&lt;field name="address" fieldType="char" /&gt; 
		&lt;field name="pcode" fieldType="char" /&gt; 
		&lt;field name="city" fieldType="char" /&gt; 
		&lt;interceptor
 
		className = "com.foo.bar.CustomerValidatonChecker"
 
		/&gt; 
		&lt;interceptor
 
		className = "com.foo.bar.TransactionLogger"
 
		/&gt; 
		&lt;/table&gt; 
		</programlisting>
			</example>
			<para>The semantics of these declarations could be described as follows:
</para>
			<para>
				<emphasis role="italic">Invoke </emphasis>
				<computeroutput>com.foo.bar.CustomerValidatonChecker</computeroutput>
				<emphasis role="italic"> and </emphasis>
				<computeroutput>com.foo.bar.TransactionLogger</computeroutput>
				<emphasis role="italic">, if the user is about to read, insert, update or delete data from table </emphasis>
				<computeroutput>customer and call the appropriate methods on those objects</computeroutput>
				<emphasis role="italic"/>
			</para>
		</sect1>
		<sect1>
			<title>Example
</title>
			<para>In this example, we override 2 methods (preInsert and preUpdate) to do some basic validation checking.
</para>
			<para>
				<computeroutput>public class CheckCustomerData extends DbEventInterceptorSupport {</computeroutput>
			</para>
			<para>
				<computeroutput>private int checkCustomer(Hashtable fieldValues) // method invented by developer</computeroutput>
			</para>
			<para>
				<computeroutput>throws ValidationException {</computeroutput>
			</para>
			<para>
				<computeroutput>String lastName = (String) fieldValues.get("lastname");</computeroutput>
			</para>
			<para>
				<computeroutput>String pCode = (String) fieldValues.get("pcode");</computeroutput>
			</para>
			<para>
				<computeroutput>String city = (String) fieldValues.get("city");</computeroutput>
			</para>
			<para>
				<computeroutput>if(lastName == null || lastName.trim().length()==0 ||   // perform form-validation</computeroutput>
			</para>
			<para>
				<computeroutput>pCode == null || pCode.trim().length()==0 ||</computeroutput>
			</para>
			<para>
				<computeroutput>city == null || city.trim().length()==0)  {</computeroutput>
			</para>
			<para>
				<computeroutput>throw new ValidationException("Please fill out the form completely!");</computeroutput>
			</para>
			<para>
				<computeroutput>} else</computeroutput>
			</para>
			<para>
				<computeroutput>return GRANT_OPERATION;</computeroutput>
			</para>
			<para>
				<computeroutput>}</computeroutput>
			</para>
			<para>
				<computeroutput>public int preInsert(HttpServletRequest request, Hashtable fieldValues, DbFormsConfig</computeroutput>
			</para>
			<para>
				<computeroutput>config, Connection con)</computeroutput>
			</para>
			<para>
				<computeroutput>throws ValidationException {</computeroutput>
			</para>
			<para>
				<computeroutput>return checkCustomer(fieldValues);</computeroutput>
			</para>
			<para>
				<computeroutput>}</computeroutput>
			</para>
			<para>
				<computeroutput>public int preUpdate(HttpServletRequest request, Hashtable fieldValues, DbFormsConfig</computeroutput>
			</para>
			<para>
				<computeroutput>config, Connection con)</computeroutput>
			</para>
			<para>
				<computeroutput>throws ValidationException {</computeroutput>
			</para>
			<para>
				<computeroutput>return checkCustomer(fieldValues);</computeroutput>
			</para>
			<para>
				<computeroutput>}</computeroutput>
			</para>
			<para>
				<computeroutput>}</computeroutput>
			</para>
			<para>Remarks:
</para>
			<para>There is an Exception ValidationException which may be thrown to signal a message to the end-user. In fact, returning the integer constant <computeroutput>DENY_OPERATION</computeroutput> defined in <computeroutput>DbEventInterceptor</computeroutput> leads to similar results (but with an unspecific error message and no generic message)
</para>
			<para>It is now possible to accumulate error messages while validating a form in a dbForms interceptor class.  This is useful in situations where many fields are validated and you wish to return several errors instead of just the first occurrence. In the validation process, when an error occurs, simply instantiate a new exception object and store it into a vector.  Do not throw this exception!  Once the validation process has completed, throw an instance of the MultipleValidationException class and pass the vector as an argument to its constructor.  Note that this functionality is dependant on using the xmlError tag. (refer to the section: DbForms Custom Tag Library for more information on using the xmlError  tag)
</para>
			<para>
				<computeroutput>Example:</computeroutput>
			</para>
			<para>
				<computeroutput>public int preUpdate(HttpServletRequest req,</computeroutput>
			</para>
			<para>
				<computeroutput>Hashtable fieldValues,</computeroutput>
			</para>
			<para>
				<computeroutput>DbformsConfig conf,</computeroutput>
			</para>
			<para>
				<computeroutput>Connection con) throws ValidationException</computeroutput>
			</para>
			<para>
				<computeroutput>{</computeroutput>
			</para>
			<para>
				<computeroutput>Vector errors = new Vector();</computeroutput>
			</para>
			<para>
				<computeroutput>// Validate, if error</computeroutput>
			</para>
			<para>
				<computeroutput>errors.add(new SQLException("English-001:param");</computeroutput>
			</para>
			<para>
				<computeroutput>// More validations, errors!</computeroutput>
			</para>
			<para>
				<computeroutput>errors.add(new SQLException("Franais-003:param,param");</computeroutput>
			</para>
			<para>
				<computeroutput>if(!errors.isEmpty)</computeroutput>
			</para>
			<para>
				<computeroutput>throw new MultipleValidationException(errors);</computeroutput>
			</para>
			<para>
				<computeroutput>}</computeroutput>
			</para>
			<para/>
		</sect1>
                   <sect1> <title>Changing Key Values in an Interceptor</title>
      
     <para>Although you could try and do it via a pluggableEvent, as it currently stands this can not be done.</para>
     
     <para>Apparently if a field is marked with isKey=&quot;true&quot; in the config file,
the preDelete and preUpdate methods disregard any changes to it.</para>
<para>Carlos Anjos pointed out:</para><para>I had a situation where I did some processing in the preDelete method
and then I wanted to allow the operation, but on a different row.
So I changed the values in the fieldValues hashtable, but still the
orginal row got deleted.</para>
<para>After banging my head for where in my code the error was, I finally
understood that dbforms was ignoring the change to that attribute.
A friend of mine went through dbforms deleteEvent code and confirmed
that.</para>
 </sect1>
	</chapter>
 
