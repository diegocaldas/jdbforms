/*
 * $Header$
 * $Revision$
 * $Date$
 *
 * DbForms - a Rapid Application Development Framework
 * Copyright (C) 2001 Joachim Peer <joepeer@excite.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */
package org.dbforms.config;
import java.util.Vector;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;


import javax.servlet.http.HttpServletRequest;
import org.apache.log4j.Category;

import org.dbforms.util.Constants;
import org.dbforms.util.FieldValue;
import org.dbforms.util.FieldValues;
import org.dbforms.util.FieldTypes;
import org.dbforms.util.ParseUtil;
import org.dbforms.util.ResultSetVector;
import org.dbforms.util.SqlUtil;
import org.dbforms.util.Util;
import org.dbforms.event.DbEventInterceptor;
import org.dbforms.event.MultipleValidationException;
import org.dbforms.event.ValidationException;



/**
 * This class represents a table tag in dbforms-config.xml (dbforms config xml file).
 * <br>
 * It also defines a lot of methods for preparing and actually performing
 * operations (queries) on the table
 *
 * @author Joe Peer <joepeer@excite.com>
 */
public class Table
{
   /** log4j category */
   private static Category logCat = Category.getInstance(Table.class.getName());

   /** id of this table (generated by DbFormsConfig when parsing dbforms-config.xml) */
   private int id;

   /** the Field-Objects this table constists of */
   private Vector fields;

   /** subset of "fields", containting those keys which represent keys */
   private Vector key;

   /** the name of the Table */
   private String name;

   /** structure for quick acessing of fields "by name" */
   private Hashtable fieldNameHash;
   private Vector    foreignKeys;

   /** access foreign key by name */
   private Hashtable foreignKeyNameHash;

   /**
    * subset of "fields", containting those keys which represent DISKBLOBs
    * (wondering about that term? -> see docu)
    */
   private Vector diskblobs;

   /**
    * instance variables concerned with the ORDERING/SORTING characterstics
    * of that table (ordering and sorting is used synonym here)
    */
   private String orderBy;

   /** the order-by clause, as specified in dbforms-config.xml (optional!) */
   private FieldValue[] defaultOrder;

   /**
    * datastructure generated from "orderBy",
    * contains Field-Objects which are referenced in the orderBy-string
    */
   private Vector defaultOrderFields;

   /**
    * access control list for this object (if null, then its open to all users
    * for all operations). Defined in dbforms-config.xml
    */
   private GrantedPrivileges grantedPrivileges = null;

   /** application hookups */
   private Vector interceptors;

   /** config object */
   protected DbFormsConfig config;

   /** Holds value of property defaultVisibleFields. */
   private String defaultVisibleFields;

   /** reference to a TableEvents object */
   private TableEvents tableEvents = null;

   /** reference to the DataAccess Class */
   private String dataAccessClass = null;

   /** some sort of alias to set in dbforms-config, not used yet */
   private String alias = null;

   /**
    * Creates a new Table object.
    */
   public Table()
   {
      fields                = new Vector();
      key                   = new Vector();
      fieldNameHash         = new Hashtable();
      diskblobs             = new Vector();
      interceptors          = new Vector();
      foreignKeys           = new Vector();
      foreignKeyNameHash    = new Hashtable();
   }

   /**
    * returns object containing info about rights mapped to user-roles.
    * (context: this table object!)
    *
    * @return the GrantedPrivileges object
    */
   public GrantedPrivileges getGrantedPrivileges()
   {
      return grantedPrivileges;
   }


   /**
    *  Checks if there exists a granted-privileges object and if so it
    *  queries if access/operation is possible
    *
    * @param request  the request object
    * @param privileg the privilege value
    * @return true if the user has got privileges over this table, false otherwise
    */
   public boolean hasUserPrivileg(HttpServletRequest request, int privileg)
   {
      return (grantedPrivileges == null) ? true
                                         : grantedPrivileges.hasUserPrivileg(request,
         privileg);
   }


   /**
    *  Set GrantedPrivileges, if defined in dbforms-config-xml
    *  (this method gets called from XML-digester).
    *
    * @param grantedPrivileges the grantedPrivileges object
    */
   public void setGrantedPrivileges(GrantedPrivileges grantedPrivileges)
   {
      this.grantedPrivileges = grantedPrivileges;
   }


   /**
    *  Add an interceptor to this table.
    *
    * @param interceptor the interceptor to add
    */
   public void addInterceptor(Interceptor interceptor)
   {
      interceptors.addElement(interceptor);
   }


   /**
    *  Get all the interceptor objects related to this table.
    *
    * @return a vector containing all the interceptor objects
    *         related to this table.
    */
   public Vector getInterceptors()
   {
      return interceptors;
   }


   /**
    * Check if this table has got interceptors.
    *
    * @return true if the table contains interceptors, false otherwise
    */
   public boolean hasInterceptors()
   {
      return (interceptors != null) && (interceptors.size() > 0);
   }


   /**
    * Adds a Field-Object to this table and puts it into othere datastructure
    * for further references (this method gets called from DbFormsConfig)
    *
    * @param field the Field object to add
    */
   public void addField(Field field)
   {
      field.setId(fields.size());
      fields.addElement(field);

      // if the field is (part of) the key
      if (field.isKey())
      {
         logCat.info("wow - field " + getName() + "." + field.getName()
            + " is a key");
         key.addElement(field);
      }
      else
      {
         logCat.info("field " + getName() + "." + field.getName()
            + " is NO key");
      }

      // for quicker lookup by name:
      fieldNameHash.put(field.getName(), field);

      // for quicker check for diskblobs
      if (field.getType() == FieldTypes.DISKBLOB)
      {
         diskblobs.addElement(field);
      }
   }


   /**
    *  Adds a ForeignKey-Object to this table
    *  and puts it into othere datastructure for further references
    *  (this method gets called from DbFormsConfig)
    *
    * @param fk the foreign key object
    */
   public void addForeignKey(ForeignKey fk)
   {
      fk.setId(foreignKeys.size());

      // add to vector containing all foreign keys:
      foreignKeys.addElement(fk);

      // for quicker lookup by name:
      foreignKeyNameHash.put(fk.getName(), fk);
   }


   /**
    *  Returns the Field-Objet with specified id.
    *
    * @param fieldId The id of the field to be returned
    * @return the Field object having the input id
    */
   public Field getField(int fieldId)
   {
      return (Field) fields.elementAt(fieldId);
   }


   /**
    *  Sets the ID of this table
    *  (this method gets called from DbFormsConfig).
    *
    * @param id  the id value to set
    */
   public void setId(int id)
   {
      this.id = id;
   }


   /**
    *  Returns ID of this table.
    *
    * @return the id value
    */
   public int getId()
   {
      return id;
   }


   /**
    *  Sets the name of the table
    *  (this method gets called from XML-digester)
    *
    * @param name the name of the table
    */
   public void setName(String name)
   {
      this.name = name;
   }


   /**
    *  Returns name of the table
    *
    * @return the name of this table
    */
   public String getName()
   {
      return name;
   }


   /**
    * @return String
    */
   public String getDataAccessClass()
   {
      return dataAccessClass;
   }


   /**
    * Sets the dataAccessClass.
    * @param dataAccessClass The dataAccessClass to set
    */
   public void setDataAccessClass(String dataAccessClass)
   {
      this.dataAccessClass = dataAccessClass;
   }


   /**
    * @return String
    */
   public String getAlias()
   {
      return alias;
   }


   /**
    * @param alias the alias to set
    */
   public void setAlias(String alias)
   {
      this.alias = alias;
   }


   /**
    *  Set configuration for table
    *
    * @param config the DbFormsConfig object
    */
   public void setConfig(DbFormsConfig config)
   {
      this.config = config;
   }


   /**
    *  Returns readOnly mode for table needed in DbFormTag.
    *  <br>
    *  In case of table returns always false.
    *  Should be overloaded from e.g. view!.
    *
    * @return true if the table is in readOnly mode; false otherwise
    */
   public boolean isReadOnly()
   {
      return false;
   }


   /**
    *  Returns the vector of fields this table constists of
    *
    * @return the vector of fields this table constists of
    */
   public Vector getFields()
   {
      return fields;
   }


   /**
    *  Returns the field-objects as specified by name (or null if no field with
    *  the specified name exists in this table).
    *
    * @param name The name of the field
    * @return Filed object having the input name
    */
   public Field getFieldByName(String name)
   {
      return (Field) fieldNameHash.get(name);
   }


   /**
    *  Returns the key of this table (consisting of Field-Objects
    *  representing key-fields).
    *
    * @return the key of this table (consisting of Field-Objects
    *         representing key-fields)
    */
   public Vector getKey()
   {
      return key;
   }


   /**
    *  Determinates if this table contains a diskblob field.
    *  (this method is used by DeleteEvent which needs to delete
    *  files referenced by a diskblob field).
    *
    * @return true if this table contains a diskblob field, false otherwise
    */
   public boolean containsDiskblob()
   {
      return diskblobs.size() > 0;
   }


   /**
    *  Returns a Vector of Field-Objects representing fields of type "DISKBLOB"
    *
    * @return a Vector of Field-Objects representing fields of type "DISKBLOB"
    */
   public Vector getDiskblobs()
   {
      return diskblobs;
   }


   /**
    *  This method generates a datastructure holding sorting information
    *  from "orderBy" clause in XML-config.
    */
   public void initDefaultOrder()
   {
      // if developer specified no orderBy in XML, then we set the KEYs as DEFAULT ORDER
      if (orderBy == null)
      {
         initDefaultOrderFromKeys();

         return;
      }

      // build the datastructure, containing Fields, and infos about sort
      defaultOrder    = this.createOrderFieldValues(orderBy, null, true);

      // building a list of the fields contained in the defaultOrder structure
      defaultOrderFields = new Vector();

      for (int i = 0; i < defaultOrder.length; i++)
         defaultOrderFields.addElement(defaultOrder[i].getField());

      logCat.info("Table.initDefaultOrder done.");
   }


   /**
    *  This method generated a datastructure holding sorting information from
    *  "orderBy" only the keys are used as order criteria.
    *  By default all ascending (check SQL spec + docu).
    */
   public void initDefaultOrderFromKeys()
   {
      defaultOrder          = new FieldValue[getKey().size()];
      defaultOrderFields    = new Vector();

      for (int i = 0; i < this.getKey().size(); i++)
      {
         Field keyField = (Field) getKey().elementAt(i);
         defaultOrder[i] = new FieldValue();
         defaultOrder[i].setField(keyField);
         defaultOrderFields.addElement(keyField);
      }

      logCat.info("Table.initDefaultOrderfromKey done.");
   }


   /**
    *  Sets a default-orderBy clause from xml config
    *  (this method gets called from XML-digester).
    *
    * @param orderBy the orderBy clause
    */
   public void setOrderBy(String orderBy)
   {
      this.orderBy = orderBy;
   }


   /**
    * Return default-orderBy clause from xml config or null if not specified.
    *
    * @return the default-orderBy clause from xml config
    *         or null if not specified.
    */
   public String getOrderBy()
   {
      return orderBy;
   }


   /**
    *  Return the datastructure containing info about the default
    *  sorting behavior of this table.
    *
    * @return the datastructure containing info about the default
    *         sorting behavior of this table.
    */
   public FieldValue[] getDefaultOrder()
   {
      return defaultOrder;
   }


   /**
    *  Return a list of the fields contained in the defaultOrder structure.
    *
    * @return a list of the fields contained in the defaultOrder structure
    */
   public Vector getDefaultOrderFields()
   {
      return defaultOrderFields;
   }


   /**
    *  Get the table events object related to this table.
    *  <br>
    *  If it is null (because user didn't specify custom events),
    *  set a new TableEvents object and return its reference.
    *
    * @return the table events object related to this table
    */
   public TableEvents getTableEvents()
   {
      if (tableEvents == null)
      {
         tableEvents = new TableEvents();
      }

      return tableEvents;
   }


   /**
    *  Set the table events object related to this table.
    *
    * @param tableEvents  the table events object related to this table
    */
   public void setTableEvents(TableEvents tableEvents)
   {
      this.tableEvents = tableEvents;
      tableEvents.setTable(this);
   }


   //------------------------------ SQL methods ---------------------------------

   /**
    *  Get the SQL select statement.
    *
    * @return the SQL select statement
    */
   public String getSelectStatement()
   {
      StringBuffer queryBuf = new StringBuffer();
      queryBuf.append("SELECT ");
      queryBuf.append(getQuerySelect(fields));
      queryBuf.append(" FROM ");
      queryBuf.append(getQueryFrom());
      logCat.info(queryBuf.toString());

      return queryBuf.toString();
   }


   /**
    *  Generates part of a field list for a  SQL SELECT clause selecting
    *  the DISKBLOB fields from a table (used by DeleteEvent to maintain
    *  data consistence).
    *
    * @return a part of a field list for a SQL SELECT clause selecting
    *         the DISKBLOB fields from a table
    */
   public String getDisblobSelectStatement()
   {
      StringBuffer buf = new StringBuffer();
      buf.append("SELECT ");

      int cnt = diskblobs.size();

      for (int i = 0; i < cnt; i++)
      {
         Field diskblobField = (Field) diskblobs.elementAt(i);

         // get the name of the encoded key field
         buf.append(diskblobField.getName());

         if (i < (cnt - 1))
         {
            buf.append(", ");
         }
      }

      buf.append(" FROM ");
      buf.append(getQueryFrom());

      return buf.toString();
   }


   /**
    *  Returns SQL delete statement, used by deleteEvent.
    *
    * @return the SQL delete statement
    */
   public String getDeleteStatement()
   {
      // now we start building the DELETE statement
      StringBuffer queryBuf = new StringBuffer();
      queryBuf.append("DELETE FROM ");
      queryBuf.append(getQueryToChange());
      queryBuf.append(" WHERE ");
      queryBuf.append(getWhereClauseForPS());
      logCat.info(queryBuf.toString());

      return queryBuf.toString();
   }


   /**
    *  Returns SQL update statement, used by updateEvent.
    *
    * @param fieldValues the Hashtable object containing the field values
    * @return the SQL update statement
    */
   public String getUpdateStatement(FieldValues fieldValues)
   {
      StringBuffer queryBuf = new StringBuffer();
      queryBuf.append("UPDATE ");
      queryBuf.append(getQueryToChange());
      queryBuf.append(" SET ");

      // list the names of fields and the place holder for their new values
      // important: these are the fields which are sent throug the current request;
      // this list may be only a subset of the field list, it is not necessarily the complete field list of a table!
      Vector      fields      = getFields();
      Enumeration enum        = fieldValues.keys();
      boolean     kommaNeeded = false;

      while (enum.hasMoreElements())
      {
         String fieldName = (String) enum.nextElement();

         if (kommaNeeded)
         {
            queryBuf.append(", ");
         }
         else
         {
            kommaNeeded = true;
         }

         queryBuf.append(fieldName);
         queryBuf.append("= ?");
      }

      queryBuf.append(" WHERE ");
      queryBuf.append(getWhereClauseForPS());
      logCat.info(queryBuf.toString());

      return queryBuf.toString();
   }


   /**
    *  Returns SQL insert statement, used by insertEvent.
    *
    * @param fieldValues the Hashtable containing the field values
    * @return the SQL insert statement
    */
   public String getInsertStatement(FieldValues fieldValues)
   {
      StringBuffer queryBuf = new StringBuffer();
      queryBuf.append("INSERT INTO ");
      queryBuf.append(getQueryToChange());
      queryBuf.append(" (");

      // list the names of fields we'll include into the insert operation
      Vector      fields = getFields();
      Enumeration enum = fieldValues.keys();

      while (enum.hasMoreElements())
      {
         String fieldName = (String) enum.nextElement();
         queryBuf.append(fieldName);

         if (enum.hasMoreElements())
         {
            queryBuf.append(",");
         }
      }

      // list the place-holders for the fields to include
      queryBuf.append(") VALUES (");

      for (int i = 0; i < fieldValues.size(); i++)
      {
         if (i != 0)
         {
            queryBuf.append(",");
         }

         queryBuf.append("?");
      }

      queryBuf.append(")");
      logCat.info(queryBuf.toString());

      return queryBuf.toString();
   }


   /**
    *  Returns the select part of a query.
    *
    * @param fieldsToSelect the vector containing the Field objects
    *                       used to build the elect part of the query
    * @return               the select part of a query
    */
   protected String getQuerySelect(Vector fieldsToSelect)
   {
      StringBuffer buf                = new StringBuffer();
      int          fieldsToSelectSize = fieldsToSelect.size();

      // #checkme: do i need this when using Hotspot ?
      // we scroll through vector directly (no enumeration!)
      // to maintain correct order of elements
      for (int i = 0; i < fieldsToSelectSize; i++)
      {
         Field f = (Field) fieldsToSelect.elementAt(i);
         buf.append(f.getName());
         buf.append(", ");
      }

      buf.deleteCharAt(buf.length() - 2);

      return buf.toString();
   }


   /**
    *  Returns the FROM part of a query.
    *
    * @return the FROM part of a query
    */
   protected String getQueryFrom()
   {
      return name;
   }


   /**
    *  Returns the FROM part of a insert/delete/update query.
    *
    * @return the FROM part of a insert/delete/update query
    */
   protected String getQueryToChange()
   {
      return getQueryFrom();
   }


   /**
    *  Returns the WHERE part of a query.
    *
    * @param fvEqual     FieldValue array used to restrict a set in a subform where
    *                    all "childFields" in the  resultset match their respective
    *                    "parentFields" in main form
    * @param fvOrder     FieldValue array used to build a cumulation of rules for ordering
    *                    (sorting) and restricting fields
    * @param compareMode compare mode value
    * @return the WHERE part of a query
    */
   protected String getQueryWhere(FieldValue[] fvEqual, FieldValue[] fvOrder,
      int compareMode)
   {
      boolean      firstTermExists = false;
      StringBuffer buf = new StringBuffer();

      // build the first term;
      if ((fvEqual != null) && (fvEqual.length > 0))
      {
         // check if the fieldvalues contain _search_ information
         buf.append(" ( ");

         if (fvEqual[0].getSearchMode() == Constants.SEARCHMODE_NONE)
         {
            buf.append(FieldValue.getWhereClause(fvEqual));
         }
         else
         {
            buf.append(FieldValue.getWhereEqualsSearchClause(fvEqual));
         }

         buf.append(" ) ");
         firstTermExists = true;
      }

      // build the second term;
      // this SHOULD be the WHERE clause which restricts
      // the query to rows coming AFTER the row containing the actual data.
      if ((fvOrder != null) && (fvOrder.length > 0))
      {
         if (compareMode != Constants.COMPARE_NONE)
         {
            buf.append(firstTermExists ? " AND ( " : "");
            buf.append(FieldValue.getWhereAfterClause(fvOrder, compareMode));
            buf.append(firstTermExists ? " ) " : "");
         }
      }

      return buf.toString();
   }


   /**
    *  Returns the part of the orderby-clause represented by this
    *  FieldValue object.
    *  <br>
    *  (ASC will be not printed because it is defined DEFAULT in SQL
    *  if there are RDBMS which do not tolerate this please let me know;
    *  then i'll change it).
    *
    * @param fvOrder FieldValue array used to build a cumulation of rules for
    *                ordering (sorting) and restricting fields
    * @return the part of the orderby-clause represented by this
    *         FieldValue object
    */
   protected String getQueryOrderBy(FieldValue[] fvOrder)
   {
      StringBuffer buf = new StringBuffer();

      if (fvOrder != null)
      {
         for (int i = 0; i < fvOrder.length; i++)
         {
            buf.append(fvOrder[i].getField().getName());

            if (fvOrder[i].getSortDirection() == Constants.ORDER_DESCENDING)
            {
               buf.append(" DESC");
            }

            if (i < (fvOrder.length - 1))
            {
               buf.append(",");
            }
         }
      }

      return buf.toString();
   }


   /**
    *  Prepares the Querystring for the select statement
    *  if the statement is for a sub-form (=> doConstrainedSelect),
    *  we set some place holders for correct mapping
    *
    * @param fieldsToSelect  vector of fields to be selected
    * @param fvEqual         fieldValues representing values we are looking for
    * @param fvOrder         fieldValues representing needs for order clauses
    * @param compareMode     and / or
    * @return the query string
    */
   public String getSelectQuery(Vector fieldsToSelect, FieldValue[] fvEqual,
      FieldValue[] fvOrder, int compareMode)
   {
      StringBuffer buf = new StringBuffer();
      buf.append("SELECT ");
      buf.append(getQuerySelect(fieldsToSelect));
      buf.append(" FROM ");
      buf.append(getQueryFrom());

      String s;
      s = getQueryWhere(fvEqual, fvOrder, compareMode);

      if (s.length() > 0)
      {
         buf.append(" WHERE ( ");
         buf.append(s);
         buf.append(")");
      }

      s = getQueryOrderBy(fvOrder);

      if (s.length() > 0)
      {
         buf.append(" ORDER BY ");
         buf.append(s);
      }

      logCat.info("::getSelectQuery - [" + buf.toString() + "]");

      return buf.toString();
   }


   /**
    *  Prepares the Querystring for the free form select statement
    *
    * @param fieldsToSelect  vector of fields to be selected
    * @param whereClause     free-form whereClause to be appended to query
    * @param tableList       the list of tables involved into the query
    * @return the query string
    */
   public String getFreeFormSelectQuery(Vector fieldsToSelect,
      String whereClause, String tableList)
   {
      StringBuffer buf = new StringBuffer();
      buf.append("SELECT ");
      buf.append(getQuerySelect(fieldsToSelect));
      buf.append(" FROM ");

      if (Util.isNull(tableList))
      {
         buf.append(getQueryFrom());
      }
      else
      {
         buf.append(tableList);
      }

      buf.append(" ");
      buf.append(whereClause);
      logCat.info("::getFreeFormSelectQuery -- [" + buf.toString() + "]");

      return buf.toString();
   }

	/**
	 * situation: we have built a query (involving the getWhereEqualsClause() method)
	 * and now we want to prepare the statemtent - provide actual values for the
	 * the '?' placeholders
	 *
	 * @param  fv the array of FieldValue objects
	 * @param  ps the PreparedStatement object
	 * @param  curCol the current PreparedStatement column; points to a
	 *                PreparedStatement xxx value
	 * @return  the current column value
	 * @exception  SQLException if any error occurs
	 */
	protected int populateWhereEqualsClause(FieldValue[] fvEqual,
		PreparedStatement ps, int curCol) throws SQLException
	{
		return FieldValue.populateWhereEqualsClause(fvEqual, ps, curCol);
	}


   /**
    *  Get the SQL ResultSet from the query builded using the input data.
    *
    * @param fvEqual     FieldValue array used to restrict a set in a subform where
    *                    all "childFields" in the  resultset match their respective
    *                    "parentFields" in main form
    * @param fvOrder     FieldValue array used to build a cumulation of rules for ordering
    *                    (sorting) and restricting fields
    * @param compareMode the value of the compare mode
    * @param ps          the PreparedStatement object
    * @return a ResultSet object
    * @throws SQLException if any error occurs
    */
   public ResultSet getDoSelectResultSet(FieldValue[] fvEqual,
      FieldValue[] fvOrder, int compareMode, PreparedStatement ps)
      throws SQLException
   {
      // the index of the first NOT POPULATED placeholder;
      int curCol = 1;

      logCat.debug("###getDoSelectResultSet pos1");

      // build a query (involving the getWhereEqualsClause() method)
      // and prepare the statemtent, providing the actual values for the
      // the '?' placeholders
      if ((fvEqual != null) && (fvEqual.length > 0))
      {
         logCat.debug("###getDoSelectResultSet pos2");
         curCol = populateWhereEqualsClause(fvEqual, ps, curCol);
         logCat.debug("###getDoSelectResultSet pos3");
      }

      logCat.debug("###getDoSelectResultSet pos4");

      if ((compareMode != Constants.COMPARE_NONE) && (fvOrder != null)
               && (fvOrder.length > 0))
      {
         logCat.debug("###getDoSelectResultSet pos5");
         FieldValue.populateWhereAfterClause(fvOrder, ps, curCol);
         logCat.debug("###getDoSelectResultSet pos6");
      }

      logCat.debug("###getDoSelectResultSet pos7");

      ResultSet result = null;

      try
      {
         result = ps.executeQuery();
      }
      catch (SQLException sqle)
      {
         SqlUtil.logSqlException(sqle);
         throw sqle;
      }

      return result;
   }


   //------------------------------ Old ResultSetVector stuff ---------------------------------

   /**
    *  Do a constrained select.
    *
    * @param fieldsToSelect vector containing all the fields to select
    * @param fvEqual FieldValue array used to restrict a set in a subform where
    *                all "childFields" in the  resultset match their respective
    *                "parentFields" in main form
    * @param fvOrder FieldValue array used to build a cumulation of rules for ordering
    *                (sorting) and restricting fields
    * @param compareMode the value of the compare mode
    * @param maxRows the max number of rows to manage
    * @param con the connection object
    * @return a ResultSetVector object
    * @throws SQLException if any error occurs
    */
   public ResultSetVector doConstrainedSelect(Vector fieldsToSelect,
      FieldValue[] fvEqual, FieldValue[] fvOrder, int compareMode, int maxRows,
      Connection con) throws SQLException
   {
      String            query = getSelectQuery(fieldsToSelect, fvEqual,
            fvOrder, compareMode);
      PreparedStatement ps = con.prepareStatement(query);
      ps.setMaxRows(maxRows); // important when quering huge tables

      ResultSet       rs     = getDoSelectResultSet(fvEqual, fvOrder,
            compareMode, ps);
      ResultSetVector result = new ResultSetVector(fieldsToSelect, rs);
      ps.close();
      logCat.info("::doConstrainedSelect - rsv size = " + result.size());

      return result;
   }


   /**
    *  perform free-form select query
    *
    *  @param fieldsToSelect vector of fields to be selected
    *  @param whereClause    free-form whereClause to be appended to query
    *  @param maxRows        how many rows should be stored in the resultSet (zero means unlimited)
    *  @param tableList      the list of tables involved into the query
    *  @param con            the active db connection to use
    *  @return the ResultSetVector object
    *  @throws SQLException if any error occurs
    */
   public ResultSetVector doFreeFormSelect(Vector fieldsToSelect,
      String whereClause, String tableList, int maxRows, Connection con)
      throws SQLException
   {
      Statement       stmt   = con.createStatement();
      ResultSet       rs;
      ResultSetVector result;
      String          query = getFreeFormSelectQuery(fieldsToSelect,
            whereClause, tableList);
      stmt.setMaxRows(maxRows); // important when quering huge tables

      try
      {
         rs = stmt.executeQuery(query);
      }
      catch (SQLException sqle)
      {
         SqlUtil.logSqlException(sqle);
         throw new SQLException(sqle.getMessage());
      }

      result = new ResultSetVector(fieldsToSelect, rs);

      // 20021115-HKK: resultset is closed in ResultSetVector()
      // rs.close();
      stmt.close();
      logCat.info("rsv size=" + result.size());

      return result;
   }


   //------------------------------ dealing with Postion and key Strings ---------------------------------

   /**
    *  Creates a token string with the format:
    *  <pre>
    *    field.id : field.length : field.value
    *  </pre>
    *
    * @param field  the field object
    * @param fieldValue the field value
    * @return the token string
    */
   private String createToken(Field field, String fieldValue)
   {
      StringBuffer buf = new StringBuffer();

		buf.append(field.getId());
		buf.append(":");
      if (!Util.isNull(fieldValue))
      {
         buf.append(fieldValue.length());
         buf.append(":");
         buf.append(fieldValue);
      } else {
			buf.append(0);
			buf.append(":");
      }

      return buf.toString();
   }


   /**
    *  Does basically the same as getPositionString but only for key-fields.
    *  <br>
    *  #checkme: could be merged with getPositionString<br>
    *  #fixme: replace seperator-based tokenization by better algoithm!
    *
    * @param rsv the ResultSetVector object
    * @return the position string for key fields
    */
   public String getKeyPositionString(ResultSetVector rsv)
   {
      if (Util.isNull(rsv))
      {
         return null;
      }

      String[] currentRow = rsv.getCurrentRow();

      if (currentRow == null)
      {
         return null;
      }

      return getKeyPositionString(currentRow);
   }


   /**
    *  Does basically the same as getPositionString but only for key-fields.
    *
    * @param currentRow the currentRow as String[]
    * @return the position string
    */
   public String getKeyPositionString(String[] currentRow)
   {
      StringBuffer buf = new StringBuffer();

      if (currentRow != null)
      {
         for (int i = 0; i < getKey().size(); i++)
         {
            Field f = (Field) getKey().elementAt(i);

            if (i > 0)
            {
               buf.append("-"); // control byte
            }

            buf.append(createToken(f, currentRow[f.getId()]));
         }
      }

      return buf.toString();
   }


   /**
    * Get key position from the input hash table
    *
    * @param  fvHT has field as key and FieldValue as value!
    *
    * @return the key position string
    */
   public String getKeyPositionString(FieldValues fvHT)
   {
      if (fvHT != null)
      {
			StringBuffer buf  = new StringBuffer();
			int cnt = 0;
			for (int i = 0; i < getKey().size(); i++)
			{
				Field f = (Field) getKey().elementAt(i);
				FieldValue fv = fvHT.get(f.getName());
				if (fv != null) 
				{
					String value = fv.getFieldValue();
					if (value == null)
					{
						throw new IllegalArgumentException("wrong fields provided");
					}
					if (cnt > 0)
					{
						buf.append("-"); // control byte
					}
					buf.append(createToken(f, value));
					cnt++;
				}
			}
         return buf.toString();
      }
      else
      {
         return null;
      }
   }

   /**
    *  Builds a "position- string" representing the values of the current row in the given
    *  ResultSetVector.
    *  <br>
    *  Not all field-values get explicitl listed in this string. only fields important
    *  for navigation and sorting are listed.
    *  <br>
    *  Position strings are used as request parameters allowing the framework to keep track
    *  of the position the user comes from or goes to.
    *  <br>
    *  Look into com.itp.tablib.DbFormTag for better understanding
    *
    * changed 0-04-2001 by joe
    * #note: enhanced algorithm since version 0.9!
    *
    * @param rsv the ResultSetVector object
    * @return the position string
    */
   public String getPositionString(ResultSetVector rsv)
   {
      if (Util.isNull(rsv))
      {
         return null;
      }

      String[] currentRow = rsv.getCurrentRow();

      if (currentRow == null)
      {
         return null;
      }

      return getPositionString(currentRow);
   }


   /**
    *  Builds a "position- string" representing the values of the current row in the given
    *  ResultSetVector.
    *  <br>
    *  Not all field-values get explicitly listed in this string. only fields important
    *  for navigation and sorting are listed.
    *  <br>
    *  Position strings are used as request parameters allowing the framework to keep track
    *  of the position the user comes from or goes to.
    *  <br>
    *
    * @param currentRow the currentRow as String[]
    * @return the position string
    */
   public String getPositionString(String[] currentRow)
   {
      StringBuffer buf = new StringBuffer();
      int          cnt = 0;

      for (int i = 0; i < getFields().size(); i++)
      {
         Field f = (Field) getFields().elementAt(i);

         if (f.isKey() || f.isFieldSortable())
         {
            if (cnt > 0)
            {
               buf.append("-"); // control byte
            }

            buf.append(createToken(f, currentRow[f.getId()]));
            cnt++;
         }
      }

      return buf.toString();
   }


   /**
    *  Used for instance by goto with prefix
    *
    * @param ht the Hashtable object containing the field names
    *           used to build the position string
    *         ht has fieldName as key and valueStr as value!
    * @return the position string
    */
   public String getPositionString(Hashtable ht)
   {
      StringBuffer buf  = new StringBuffer();
      int          cnt  = 0;
      Enumeration  enum = ht.keys();

      while (enum.hasMoreElements())
      {
         String fieldName = (String) enum.nextElement();
         Field  aField = getFieldByName(fieldName);

         if ((aField != null) && (aField.isKey() || aField.isFieldSortable()))
         {
            String fieldValue = (String) ht.get(fieldName);

            if (cnt > 0)
            {
               buf.append('-'); // control byte
            }

            buf.append(createToken(aField, fieldValue));
            cnt++;
         }
         else
         {
            logCat.error("provided goto field " + fieldName + " not found!");
         }
      }

      return buf.toString();
   }


   /**
    * Get key position from the input hash table
    *
    * @param  fvHT has field as key and FieldValue as value!
    *
    * @return the key position string
    */
   public String getPositionString(FieldValues fvHT)
   {
      if (fvHT != null)
      {
         StringBuffer buf  = new StringBuffer();
         int          cnt  = 0;
         Enumeration  enum = fvHT.keys();

         while (enum.hasMoreElements())
         {
            String     fieldName = (String) enum.nextElement();
            FieldValue fv = fvHT.get(fieldName);
            Field      f  = fv.getField();

            if (f.isKey() || f.isFieldSortable())
            {
               String value = fv.getFieldValue();

               if (value == null)
               {
                  throw new IllegalArgumentException("wrong fields provided");
               }

               if (cnt > 0)
               {
                  buf.append("-"); // control byte
               }

               buf.append(createToken(f, value));
               cnt++;
            }
         }

         return buf.toString();
      }
      else
      {
         return null;
      }
   }


   /**
    *  This method parses a position string and build a data structure
    *  representing the values of the fields decoded from the position.
    *  <br>
    *  #fixme: replace seperator-based tokenization by better algoithm!
    *
    * @param position the position string
    * @return the HashTable containing the FieldValues of the fields decoded,
    *          key of the HashTable is the fieldName!
    */
   public FieldValues getFieldValues(String position)
   {
      // 20020705-HKK: Position maybe string with length = 0!!!!
      if ((position == null) || (position.length() == 0))
      {
         return null;
      }

      // trailing blanks are significant for CHAR database fields
      //	position = position.trim();
      // 20021128-HKK: catch errors!
      // 2003-03-29 HKK: Change from Hashtable to FieldValueTable
      FieldValues result = new FieldValues();

      try
      {
         int     startIndex  = 0;
         boolean endOfString = false;

         // looping through the string
         while (!endOfString)
         {
            int firstColon  = position.indexOf(':', startIndex);
            int secondColon = position.indexOf(':', firstColon + 1);

            if ((firstColon == -1) && (secondColon == -1))
            {
               return null;
            }

            String fieldIdStr = position.substring(startIndex, firstColon);
            int    fieldId = Integer.parseInt(fieldIdStr);

            String valueLengthStr = position.substring(firstColon + 1,
                  secondColon);
            int    valueLength = Integer.parseInt(valueLengthStr);

            int    controlIndex = secondColon + 1 + valueLength;

            // make already be trimmed ... avoid substring exception
            String valueStr = (controlIndex < position.length())
               ? position.substring(secondColon + 1, controlIndex)
               : position.substring(secondColon + 1);

            Field  f  = getField(fieldId);
            FieldValue fv = new FieldValue(f, valueStr);
            result.put(f.getName(), fv);

            if (controlIndex == position.length())
            {
               endOfString = true;
            }
            else if (controlIndex > position.length())
            {
               logCat.warn("Controlbyte wrong but continuing execution");
               endOfString = true;
            }
            else
            {
               char controlByte = position.charAt(controlIndex);

               if (controlByte != '-')
               {
                  logCat.error("Controlbyte wrong, abandon execution");
                  throw new IllegalArgumentException();
               }

               startIndex = controlIndex + 1;

               if (position.length() == startIndex)
               {
                  endOfString = true;
               }
            }
         }
      }
      catch (Exception e)
      {
         logCat.error("::getFieldValuesFromPositionAsHt - exception:", e);
         result = null;
      }

      return result;
   }


   /**
    *  Transfer values from asscociative (name-orientated, user friendly) hashtable
    *  [param 'assocFv'] into hashtable used interally by DbForms used during
    *  parameter-passing for interceptors
    *
    * @param fv the fv to put the FieldValues in
    * @param assocFv the assosiative Array the data comes from
    */
   public void synchronizeData(FieldValues fv, Hashtable assocFv)
   {
      Enumeration enum = assocFv.keys();

      while (enum.hasMoreElements())
      {
         String aFieldName = (String) enum.nextElement();
         Field  f = this.getFieldByName(aFieldName);

         if (f != null)
         {
            String newValue = (String) assocFv.get(aFieldName);

            if (newValue != null)
            {
               FieldValue v = new FieldValue(f, newValue);
               fv.put(f.getName(), v);
            }
         }
      }
   }


   /**
    *  in version 0.9 this method moved from FieldValue.fillWithValues to Table.fillWithValues
    *
    * @param orderConstraint  FieldValue array used to build a cumulation of rules
    *                         for ordering (sorting) and restricting fields
    * @param aPosition        resultset position
    */
   public void fillWithValues(FieldValue[] orderConstraint, String aPosition)
   {
      // 2003-03-29 HKK: Change from Hashtable to FieldValueTable 
      FieldValues ht = getFieldValues(aPosition);

      // 20021104-HKK: Error handling if aPosition is not given!
      if (ht != null)
      {
         logCat.info("*** parsing through: " + aPosition);

         // then we copy some of those values into the orderConstraint
         for (int i = 0; i < orderConstraint.length; i++)
         {
            Field f = orderConstraint[i].getField();

            if (f != null)
            {
               FieldValue aFieldValue = ht.get(f.getName());

               if (aFieldValue != null)
               {
                  orderConstraint[i].setFieldValue(aFieldValue.getFieldValue());
               }
               else
               {
                  logCat.warn("position entry has null value:" + f.getName());
               }
            }
         }
      }
   }


   // ----------------- some convenience methods ---------------------------------------------

   /**
    *  Generates a part of the SQL where clause needed to select a distinguished row form the table.
    *  This is done by querying for KEY VALUES !
    *
    * @return  a part of the SQL where clause needed to select a distinguished
    *          row form the table
    */
   public String getWhereClauseForPS()
   {
      StringBuffer buf = new StringBuffer();
      int          cnt = this.getKey().size();

      for (int i = 0; i < cnt; i++)
      {
         Field keyField = (Field) this.getKey().elementAt(i);

         // get the name of the encoded key field
         buf.append(keyField.getName());
         buf.append(" = ?");

         if (i < (cnt - 1))
         {
            buf.append(" AND ");
         }
      }

      return buf.toString();
   }


   /**
    *  POPULATES a part of the SQL where clause needed to select a distinguished
    *  row form the table using values endcoded in a string.
    *  <br>
    *  #fixme: replace seperator-based tokenization by better algoithm!
    *
    * @param  keyValuesStr the position string
    * @param  ps           the PreparedStatement object
    * @param  startColumn  PreparedStatement start column
    * @throws SQLException if any error occurs
    */
   public void populateWhereClauseForPS(String keyValuesStr,
      PreparedStatement ps, int startColumn) throws SQLException
   {
      int col = startColumn;

      // then we list the values of the key-fields, so that the WHERE clause
      // matches the right dataset
      // 2003-03-29 HKK: Change from Hashtable to FieldValueTable 
      FieldValues keyValuesHt = getFieldValues(keyValuesStr);
      int         keyLength = this.getKey().size();

      for (int i = 0; i < keyLength; i++)
      {
         Field      curField    = (Field) this.getKey().elementAt(i);
         FieldValue aFieldValue = keyValuesHt.get(curField.getName());
         String     valueStr    = aFieldValue.getFieldValue();
         SqlUtil.fillPreparedStatement(ps, col, valueStr, curField.getType());
         col++;
      }
   }


   /**
    *  The orderBy clause usually defaults to ASCending order.
    *  A user may add, if we/she wishes the keyword ASC (ascending)
    *  or DESC (descending) to specify a particular direction.
    *  <br>
    *  Code in this method parses the orderBy clause and finds an occurence
    *  of either ASC or DESC.  Suppose your field name is "DESCRIPTION" !
    *  <br>
    *  This name contains "DESC" therefore causing unexpected behaviour.
    *  This bug fix consists of fine-tunning the parsing function to take into
    *  consideration the sequence of parameters: 1-Field 2-Command
    *
    * @param order order string
    * @return a vector of Field objects
    *
    * @author Grunikiewicz.philip@hydro.qc.ca
    * @date   2001-08-09
    */
   private Vector createOrderFVFromAttribute(String order)
   {
      Vector result = new Vector();

      if (order != null)
      {
         StringTokenizer st = new StringTokenizer(order, ",");

         while (st.hasMoreTokens())
         {
            //Remove leading and trailing white space characters.
            String token = st.nextToken().trim();
            logCat.info("token = " + token);

            FieldValue fv            = new FieldValue();
            boolean    sortDirection = Constants.ORDER_ASCENDING;

            // we propose the default
            //Separate field from command
            int index = token.indexOf(" ");

            // Blank space used between field and command
            if (index != -1) // Do we have a command, if not assume ASC order
            {
               String command = token.substring(index);
               int    pos = command.indexOf("ASC");

               if (pos == -1) // ASC not found, try descending
               {
                  pos = command.indexOf("DESC");

                  if (index != -1)
                  {
                     sortDirection = Constants.ORDER_DESCENDING;

                     // ... we set DESC.
                  }
               }
            }

            String fieldName;

            if (index == -1)
            {
               fieldName = token.trim();
            }
            else
            {
               fieldName = token.substring(0, index).trim();
            }

            Field f = this.getFieldByName(fieldName);

            if (f != null)
            {
               fv.setField(f);
               fv.setSortDirection(sortDirection);
               logCat.info("Field '" + fieldName + "' is ordered in mode:"
                  + sortDirection);
               result.addElement(fv);
            }
         }
      }

      return result;
   }


   /**
    *
    * @param request
    * @param paramStub
    * @param sortFields
    * @return
    */
   private Vector createOrderFVFromRequest(HttpServletRequest request,
      String paramStub, Vector sortFields)
   {
      Vector result     = new Vector();
      int    fieldIndex = paramStub.length() + 1;

      // "sort_1" -> fieldindex= 8 (length of paramStub "order_1" is 7)
      for (int i = 0; i < sortFields.size(); i++)
      {
         String dataParam = (String) sortFields.elementAt(i);
         int    fieldId   = Integer.parseInt(dataParam.substring(fieldIndex));
         String sortState = ParseUtil.getParameter(request, dataParam);
         logCat.info("### dataparam=" + dataParam);
         logCat.info("### fieldId=" + fieldId);
         logCat.info("### sortState=" + sortState);

         if (sortState.equalsIgnoreCase("asc")
                  || sortState.equalsIgnoreCase("desc"))
         {
            boolean sortDirection = sortState.equalsIgnoreCase("asc")
               ? Constants.ORDER_ASCENDING : Constants.ORDER_DESCENDING;
            FieldValue fv = new FieldValue();
            fv.setField(this.getField(fieldId));
            fv.setSortDirection(sortDirection);
            result.addElement(fv);
         }
      }

      return result;
   }


   /**
     *  Column ["ASC" | "DESC"] {"," Column ["ASC" | "DESC"] }
     *  (if neither ASC nor DESC follow "Col", then ASC is choosen as default).
     *  <br>
     *  this method assures, that ALL KEY FIELDs are part of the order criteria,
     *  in any case (independly from the order-Str). if necessary it appends them.
     *  WHY: to ensure correct scrollig (not getting STUCK if the search criteria
     *  are not "sharp" enough).
     *  <br>
     * #fixme - better explaination
     * #fixme - determinate illegal input and throw IllegalArgumentException
     *
     * @param order       a String from JSP provided by the user in SQL-Style
     * @param request     the request object
     * @param includeKeys true to include key fields, false otherwise
     * @return            ???
     */
   public FieldValue[] createOrderFieldValues(String order,
      HttpServletRequest request, boolean includeKeys)
   {
      Vector result = null;

      if (request != null)
      {
         String paramStub  = "sort_" + this.getId();
         Vector sortFields = ParseUtil.getParametersStartingWith(request,
               paramStub);

         if (sortFields.size() > 0)
         {
            result = createOrderFVFromRequest(request, paramStub, sortFields);
         }
      }

      // 20020703-HKK: use the default order if result.size == 0, not only if result == null
      //               This happens if  all parameters with sort_  are set to none
      if (((result == null) || result.isEmpty()))
      {
         // 20021104-HKK: use default order from table if form has no order!
         if (order == null)
         {
            order = getOrderBy();
         }

         result = createOrderFVFromAttribute(order);

         logCat.debug("@@@ 1");

         for (int i = 0; i < result.size(); i++)
         {
            FieldValue fieldVal = (FieldValue) result.elementAt(i);
            logCat.debug("fieldValue " + fieldVal.toString());
         }
      }

      if ((result == null) && !includeKeys)
      {
         return null; // then we've got definitely no over
      }

      // scroll through keys and append to order criteria, if not already included
      for (int i = 0; i < this.getKey().size(); i++)
      {
         Field   keyField = (Field) getKey().elementAt(i);
         boolean found = false;
         int     j     = 0;

         while (!found && (j < result.size()))
         {
            FieldValue fv = (FieldValue) result.elementAt(j);

            if (fv.getField() == keyField)
            {
               found = true;
            }

            j++;
         }

         if (!found)
         {
            addFieldValue(result, keyField);
         }
      }

      FieldValue[] resultArray = new FieldValue[result.size()];
      result.copyInto(resultArray);
      logCat.debug("@@@ 2");

      for (int i = 0; i < resultArray.length; i++)
      {
         logCat.debug("fieldValue " + resultArray[i].toString());
      }

      return resultArray;
   }


   //------------------------------ utility / helper methods ---------------------------------

   /**
    *  This metod is useful for logging / debugging purposes only.
    *
    * @return a string containing the Table name and field values
    */
   public String traverse()
   {
      StringBuffer buf = new StringBuffer();
      buf.append("\nname=");
      buf.append(name);
      buf.append(" ");

      for (int i = 0; i < getFields().size(); i++)
      {
         Field f = (Field) getFields().elementAt(i);
         buf.append("\nfield: ");
         buf.append(f.toString());
      }

      return buf.toString();
   }


   /**
    *   helper method used locally in this class
    */
   private void addFieldValue(Vector stub, Field f)
   {
      FieldValue fv = new FieldValue();
      fv.setField(f);
      stub.addElement(fv);
   }


   /**
    *  Process the interceptor objects related to this table.
    *
    * @param action           DOCUMENT ME!
    * @param request          the request object
    * @param associativeArray DOCUMENT ME!
    * @param config           the config object
    * @param con              the JDBC connection object
    *
    * @throws SQLException if any error occurs
    * @throws MultipleValidationException if any validation error occurs
    */
   public void processInterceptors(int action, HttpServletRequest request,
      Hashtable associativeArray, DbFormsConfig config, Connection con)
      throws SQLException, MultipleValidationException
   {
      try
      {
         int interceptorsCnt = interceptors.size();

         for (int i = 0; i < interceptorsCnt; i++)
         {
            Interceptor        interceptor      = (Interceptor) interceptors
               .elementAt(i);
            Class              interceptorClass = Class.forName(interceptor
                  .getClassName());
            DbEventInterceptor dbi              = (DbEventInterceptor) interceptorClass
               .newInstance();

            if (action == DbEventInterceptor.PRE_INSERT)
            {
               if (dbi.preInsert(request, associativeArray, config, con) == DbEventInterceptor.DENY_OPERATION)
               {
                  throw new SQLException("Sorry, adding data to table "
                     + this.getName()
                     + " was not granted this time. Your request violated a condition.");
               }
            }
            else if (action == DbEventInterceptor.POST_INSERT)
            {
               dbi.postInsert(request, config, con);
            }
            else if (action == DbEventInterceptor.PRE_UPDATE)
            {
               if (dbi.preUpdate(request, associativeArray, config, con) == DbEventInterceptor.DENY_OPERATION)
               {
                  throw new SQLException("Sorry, updating data in table "
                     + this.getName()
                     + " was not granted this time. Your request violated a condition.");
               }
            }
            else if (action == DbEventInterceptor.POST_UPDATE)
            {
               dbi.postUpdate(request, config, con);
            }
            else if (action == DbEventInterceptor.PRE_DELETE)
            {
               if (dbi.preDelete(request, associativeArray, config, con) == DbEventInterceptor.DENY_OPERATION)
               {
                  throw new SQLException("Sorry, deleting data from table "
                     + this.getName()
                     + " was not granted this time. Your request violated a condition.");
               }
            }
            else if (action == DbEventInterceptor.POST_DELETE)
            {
               dbi.postDelete(request, config, con);
            }
            else if (action == DbEventInterceptor.PRE_SELECT)
            {
               if (dbi.preSelect(request, config, con) == DbEventInterceptor.DENY_OPERATION)
               {
                  throw new SQLException("Sorry, selecting data from table "
                     + this.getName()
                     + " was not granted this time. Your request violated a condition.");
               }
            }
            else if (action == DbEventInterceptor.POST_SELECT)
            {
               dbi.postSelect(request, config, con);
            }
         }

         // PG = 2001-12-04
         // No need to add extra comments, just re-throw exceptions as SqlExceptions
      }
      catch (ClassNotFoundException cnfe)
      {
         logCat.warn(" ClassNotFoundException : " + cnfe.getMessage());
         throw new SQLException(cnfe.getMessage());
      }
      catch (InstantiationException ie)
      {
         logCat.warn(" InstantiationException : " + ie.getMessage());
         throw new SQLException(ie.getMessage());
      }
      catch (IllegalAccessException iae)
      {
         logCat.warn(" IllegalAccessException : " + iae.getMessage());
         throw new SQLException(iae.getMessage());
      }
      catch (SQLException sqle)
      {
         throw new SQLException(sqle.getMessage());
      }
      catch (MultipleValidationException mve)
      {
         throw new MultipleValidationException(mve.getMessages());
      }
      catch (ValidationException ve)
      {
         throw new SQLException(ve.getMessage());
      }
   }


   /**
    * We have the field ID - we need the field name
    * 
    * @param fieldID fieldID to get field name from
    * @return the field name
    */
   public String getFieldName(int fieldID)
   {
      Field f = (Field) getFields().elementAt(fieldID);

      return (f.getName());
   }


   /**
    * returns the hash table. Moved from dbFormTag to table, so that you can overload it!
    * 
    * @param core starting tag for the fields
    * @return hash table of names 
    * 					in PHP slang we would call that an "associative array" :=)
    * 
    */
   public Hashtable getNamesHashtable(String core)
   {
      Hashtable   result = new Hashtable();
      Enumeration enum = getFields().elements();

      while (enum.hasMoreElements())
      {
         Field        f         = (Field) enum.nextElement();
         String       fieldName = f.getName();
         int          fieldId   = f.getId();
         StringBuffer sb        = new StringBuffer(core);
         sb.append("_");
         sb.append(getId());
         sb.append("_");
         sb.append(fieldId);
         result.put(fieldName, sb.toString());
      }

      return result;
   }


   /**
    * Getter for property defaultVisibleFields.
    *
    * @return Value of property defaultVisibleFields.
    */
   public String getDefaultVisibleFields()
   {
      return this.defaultVisibleFields;
   }


   /**
    * Setter for property defaultVisibleFields.
    *
    * @param defaultVisibleFields New value of property defaultVisibleFields.
    */
   public void setDefaultVisibleFields(String defaultVisibleFields)
   {
      this.defaultVisibleFields = defaultVisibleFields;
   }


   /**
    * maps chield fields to parent fields
    *
    * @param parentTable the parent table
    * @param parentFieldString field names in parent table
    * @param childFieldString  field names in child table
    * @param aPosition         position to map as position string
    *
    * @return FieldValue[] with result
    */
   public FieldValues mapChildFieldValues(Table parentTable,
      String parentFieldString, String childFieldString, String aPosition)
   {
      // 1 to n fields may be mapped
      Vector childFieldNames  = ParseUtil.splitString(childFieldString, ",;~");
      Vector parentFieldNames = ParseUtil.splitString(parentFieldString, ",;~");

      // do some basic checks
      // deeper checks like Datatyp-compatibility,etc not done yet
      int len = childFieldNames.size();

      if ((len == 0) || (len != parentFieldNames.size()))
      {
         return null;
      }

      // 2003-03-29 HKK: Change from Hashtable to FieldValueTable 
      FieldValues ht = parentTable.getFieldValues(aPosition);
      if (ht == null)
      {
         return null;
      }

      FieldValues childFieldValues = new FieldValues();
      for (int i = 0; i < len; i++)
      {
         String     parentFieldName = (String) parentFieldNames.elementAt(i);
         Field      parentField    = parentTable.getFieldByName(parentFieldName);
         String     childFieldName = (String) childFieldNames.elementAt(i);
         Field      childField     = this.getFieldByName(childFieldName);
         FieldValue aFieldValue    = ht.get(parentField.getName());

         if (aFieldValue == null)
         {
            throw new IllegalArgumentException("ERROR: Make sure that field "
               + parentField.getName() + " is a KEY of the table "
               + this.getName()
               + "! Otherwise you can not use it as PARENT/CHILD LINK argument!");
         }

         String currentParentFieldValue = aFieldValue.getFieldValue();
         childFieldValues.put(childField.getName(), new FieldValue(childField,
               currentParentFieldValue));
      }
      return childFieldValues;
   }
}
