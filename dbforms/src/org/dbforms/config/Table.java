/*
 * $Header$
 * $Revision$
 * $Date$
 *
 * DbForms - a Rapid Application Development Framework
 * Copyright (C) 2001 Joachim Peer <joepeer@excite.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */

package org.dbforms.config;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.dbforms.interfaces.DbEventInterceptorData;
import org.dbforms.interfaces.IDbEventInterceptor;
import org.dbforms.interfaces.IEscaper;
import org.dbforms.util.MessageResourcesInternal;
import org.dbforms.util.ParseUtil;
import org.dbforms.util.ReflectionUtil;
import org.dbforms.util.SqlUtil;
import org.dbforms.util.StringUtil;
import org.dbforms.util.Util;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Locale;
import java.util.StringTokenizer;
import java.util.Vector;

import java.io.Serializable;

import javax.servlet.http.HttpServletRequest;

/**
 * This class represents a table tag in dbforms-config.xml (dbforms config xml
 * file). <br>
 * It also defines a lot of methods for preparing and actually performing
 * operations (queries) on the table
 * 
 * @author Joe Peer
 */
public class Table implements Serializable {
	/** either "classic" or "interceptor", default is "interceptor" */
	public static final int BLOB_INTERCEPTOR = 0;

	/** DOCUMENT ME! */
	public static final int BLOB_CLASSIC = 1;

	private static final int MAXFIELDS = 1000;

	/** DOCUMENT ME! */
	protected static final int DB_FIELD = 0;

	/** DOCUMENT ME! */
	protected static final int SEARCH_FIELD = 1;

	/** DOCUMENT ME! */
	protected static final int CALC_FIELD = 2;

	/**
	 * access control list for this object (if null, then its open to all users
	 * for all operations). Defined in dbforms-config.xml
	 */
	private GrantedPrivileges grantedPrivileges = null;

	private Hashtable calcFieldsNameHash = new Hashtable();

	/** structure for quick acessing of fields "by name" */
	private Hashtable fieldNameHash = new Hashtable();

	/** access foreign key by name */
	private Hashtable foreignKeyNameHash = new Hashtable();

	private IEscaper escaper = null;

	/** log4j category */
	private static Log logCat = LogFactory.getLog(Table.class.getName());

	/** some sort of alias to set in dbforms-config, not used yet */
	private String alias = null;

	private String blobHandling = null;

	/** reference to the DataAccess Class */
	private String dataAccessClass = null;

	/** Holds value of property defaultVisibleFields. */
	private String defaultVisibleFields;

	/** Holds value of property defaultVisibleFieldsFormat. */
	private String defaultVisibleFieldsFormat;

	private String escaperClass = null;

	/** the name of the Table */
	private String name;

	/**
	 * instance variables concerned with the ORDERING/SORTING characterstics of
	 * that table (ordering and sorting is used synonym here)
	 */
	private String orderBy;

	/** reference to a TableEvents object */
	private TableEvents tableEvents = null;

	private Vector calcFields = new Vector();

	/**
	 * subset of "fields", containting those keys which represent DISKBLOBs
	 * (wondering about that term? -> see docu)
	 */
	private Vector diskblobs = new Vector();

	/** the Field-Objects this table constists of */
	private Vector fields = new Vector();

	private Vector foreignKeys = new Vector();

	/** application hookups */
	private Vector interceptors = new Vector();

	/** subset of "fields", containting those keys which represent keys */
	private Vector key = new Vector();

	/** the order-by clause, as specified in dbforms-config.xml (optional!) */
	private FieldValue[] defaultOrder;

	private int blobHandlingStrategy = BLOB_INTERCEPTOR;

	/**
	 * id of this table (generated by DbFormsConfig when parsing
	 * dbforms-config.xml)
	 */
	private int id;

	/**
	 * DOCUMENT ME!
	 * 
	 * @param alias
	 *            the alias to set
	 */
	public void setAlias(String alias) {
		this.alias = alias;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @return String
	 */
	public String getAlias() {
		return alias;
	}

	/**
	 * for digester only, see blobHandlingStrategy
	 * 
	 * @param blobHandling
	 *            config parameter
	 */
	public void setBlobHandling(String blobHandling) {
		this.blobHandling = blobHandling;

		if ("classic".equals(blobHandling)) {
			this.blobHandlingStrategy = BLOB_CLASSIC;
		} else {
			this.blobHandlingStrategy = BLOB_INTERCEPTOR;
		}
	}

	/**
	 * for digester only, see blobHandlingStrategy
	 * 
	 * @return String
	 */
	public String getBlobHandling() {
		return blobHandling;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @return DOCUMENT ME!
	 */
	public int getBlobHandlingStrategy() {
		return this.blobHandlingStrategy;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @return
	 */
	public Vector getCalcFields() {
		return calcFields;
	}

	/**
	 * Sets the dataAccessClass.
	 * 
	 * @param dataAccessClass
	 *            The dataAccessClass to set
	 */
	public void setDataAccessClass(String dataAccessClass) {
		this.dataAccessClass = dataAccessClass;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @return String
	 */
	public String getDataAccessClass() {
		return dataAccessClass;
	}

	/**
	 * Return the datastructure containing info about the default sorting
	 * behavior of this table.
	 * 
	 * @return the datastructure containing info about the default sorting
	 *         behavior of this table.
	 */
	public FieldValue[] getDefaultOrder() {
		return defaultOrder;
	}

	/**
	 * Setter for property defaultVisibleFields.
	 * 
	 * @param defaultVisibleFields
	 *            New value of property defaultVisibleFields.
	 */
	public void setDefaultVisibleFields(String defaultVisibleFields) {
		this.defaultVisibleFields = defaultVisibleFields;
	}

	/**
	 * Getter for property defaultVisibleFields.
	 * 
	 * @return Value of property defaultVisibleFields.
	 */
	public String getDefaultVisibleFields() {
		return this.defaultVisibleFields;
	}

	/**
	 * Setter for property defaultVisibleFieldsFormat.
	 * 
	 * @param defaultVisibleFieldsFormat
	 *            New value of property defaultVisibleFieldsFormat.
	 */
	public void setDefaultVisibleFieldsFormat(String defaultVisibleFieldsFormat) {
		this.defaultVisibleFieldsFormat = defaultVisibleFieldsFormat;
	}

	/**
	 * Getter for property defaultVisibleFieldsFormat.
	 * 
	 * @return Value of property defaultVisibleFieldsFormat.
	 */
	public String getDefaultVisibleFieldsFormat() {
		return this.defaultVisibleFieldsFormat;
	}

	/**
	 * Returns SQL delete statement, used by deleteEvent.
	 * 
	 * @return the SQL delete statement
	 */
	public String getDeleteStatement(String keyValString) {
		// now we start building the DELETE statement
		StringBuffer queryBuf = new StringBuffer();
		queryBuf.append("DELETE FROM ");
		queryBuf.append(getQueryToChange());
		queryBuf.append(" WHERE ");
		queryBuf.append(getWhereClauseForKeyFields(keyValString));

		logCat.info("::deleteQuery - [" + queryBuf.toString() + "]");
		return queryBuf.toString();
	}

	/**
	 * Generates part of a field list for a SQL SELECT clause selecting the
	 * DISKBLOB fields from a table (used by DeleteEvent to maintain data
	 * consistence).
	 * 
	 * @return a part of a field list for a SQL SELECT clause selecting the
	 *         DISKBLOB fields from a table
	 */
	public String getDisblobSelectStatement() {
		StringBuffer buf = new StringBuffer();
		buf.append("SELECT ");

		int cnt = diskblobs.size();

		for (int i = 0; i < cnt; i++) {
			Field diskblobField = (Field) diskblobs.elementAt(i);

			// get the name of the encoded key field
			buf.append(diskblobField.getName());

			if (i < (cnt - 1)) {
				buf.append(", ");
			}
		}

		buf.append(" FROM ");
		buf.append(getQueryFrom());

		return buf.toString();
	}

	/**
	 * Returns a Vector of Field-Objects representing fields of type "DISKBLOB"
	 * 
	 * @return a Vector of Field-Objects representing fields of type "DISKBLOB"
	 */
	public Vector getDiskblobs() {
		return diskblobs;
	}

	/**
	 * Get the SQL ResultSet from the query builded using the input data. Order
	 * of parts: 1. sqlFilter 2. where condition generated from searching 3.
	 * where condition generated from ordering Generating the query in
	 * getSelectQuery() must match this order!
	 * 
	 * @param fvEqual
	 *            FieldValue array used to restrict a set in a subform where all
	 *            "childFields" in the resultset match their respective
	 *            "parentFields" in main form
	 * @param fvOrder
	 *            FieldValue array used to build a cumulation of rules for
	 *            ordering (sorting) and restricting fields
	 * @param sqlFilterParams
	 *            DOCUMENT ME!
	 * @param compareMode
	 *            the value of the compare mode
	 * @param ps
	 *            the PreparedStatement object
	 * 
	 * @return a ResultSet object
	 * 
	 * @throws SQLException
	 *             if any error occurs
	 */
	public ResultSet getDoSelectResultSet(FieldValue[] fvEqual,
			FieldValue[] fvOrder, FieldValue[] sqlFilterParams,
			int compareMode, PreparedStatement ps) throws SQLException {
		// the index of the first NOT POPULATED placeholder;
		int curCol = 1;

		logCat.debug("###getDoSelectResultSet pos1");

		if (!FieldValue.isNull(sqlFilterParams)) {
			curCol = populateWhereEqualsClause(sqlFilterParams, ps, curCol);
		}

		logCat.debug("###getDoSelectResultSet pos2");

		if (!FieldValue.isNull(fvEqual)) {
			curCol = populateWhereEqualsClause(fvEqual, ps, curCol);
		}

		logCat.debug("###getDoSelectResultSet pos3");

		if ((compareMode != Constants.COMPARE_NONE) && (fvOrder != null)
				&& (fvOrder.length > 0)) {
			populateWhereAfterClause(fvOrder, ps, curCol);
		}

		logCat.debug("###getDoSelectResultSet pos3");

		ResultSet result = null;

		try {
			result = ps.executeQuery();
		} catch (SQLException sqle) {
			SqlUtil.logSqlException(sqle);
			throw sqle;
		}

		return result;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @return DOCUMENT ME!
	 */
	public IEscaper getEscaper() {
		if (escaper == null) {
			String s = getEscaperClass();

			if (!Util.isNull(s)) {
				try {
					escaper = (IEscaper) ReflectionUtil.newInstance(s);
				} catch (Exception e) {
					logCat
							.error("cannot create the new escaper [" + s + "]",
									e);
				}
			}

			if ((escaper == null)) {
				try {
					escaper = DbFormsConfigRegistry.instance().lookup()
							.getEscaper();
				} catch (Exception e) {
					logCat.error("cannot create the new default escaper", e);
				}
			}
		}

		return escaper;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @param string
	 */
	public void setEscaperClass(String string) {
		escaperClass = string;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @return
	 */
	public String getEscaperClass() {
		return escaperClass;
	}

	/**
	 * Returns the Field-Objet with specified id.
	 * 
	 * @param fieldId
	 *            The id of the field to be returned
	 * 
	 * @return the Field object having the input id
	 */
	public Field getField(int fieldId) {
		Field f = null;

		if (checkFieldId(CALC_FIELD, fieldId)) {
			f = (Field) calcFields
					.elementAt(decodeFieldId(CALC_FIELD, fieldId));
		} else {
			f = (Field) fields.elementAt(fieldId);
		}

		return f;
	}

	public boolean isCalcField(int fieldId) {
		return checkFieldId(CALC_FIELD, fieldId);
	}

	/**
	 * Returns the field-objects as specified by name (or null if no field with
	 * the specified name exists in this table).
	 * 
	 * @param name
	 *            The name of the field
	 * 
	 * @return Filed object having the input name
	 */
	public Field getFieldByName(String aname) {
		Field f = (Field) fieldNameHash.get(aname);
		if (f == null) {
			f = (Field) calcFieldsNameHash.get(aname);
		}
		return f;
	}

	/**
	 * We have the field ID - we need the field name
	 * 
	 * @param fieldID
	 *            fieldID to get field name from
	 * 
	 * @return the field name
	 */
	public String getFieldName(int fieldID) {
		Field f = (Field) getFields().elementAt(fieldID);

		return (f.getName());
	}

	/**
	 * This method parses a position string and build a data structure
	 * representing the values of the fields decoded from the position. <br>
	 * #fixme: replace seperator-based tokenization by better algoithm!
	 * 
	 * @param position
	 *            the position string
	 * 
	 * @return the HashTable containing the FieldValues of the fields decoded,
	 *         key of the HashTable is the fieldName!
	 */
	public FieldValues getFieldValues(String position) {
		// 20020705-HKK: Position maybe string with length = 0!!!!
		if (Util.isNull(position)) {
			return null;
		}

		// trailing blanks are significant for CHAR database fields
		// position = position.trim();
		// 20021128-HKK: catch errors!
		// 2003-03-29 HKK: Change from Hashtable to FieldValueTable
		FieldValues result = new FieldValues();

		try {
			int startIndex = 0;
			boolean endOfString = false;

			// looping through the string
			while (!endOfString) {
				int firstColon = position.indexOf(':', startIndex);
				int secondColon = position.indexOf(':', firstColon + 1);

				if ((firstColon == -1) && (secondColon == -1)) {
					return null;
				}

				String fieldIdStr = position.substring(startIndex, firstColon);
				int fieldId = Integer.parseInt(fieldIdStr);

				String valueLengthStr = position.substring(firstColon + 1,
						secondColon);
				int valueLength = Integer.parseInt(valueLengthStr);

				int controlIndex = secondColon + 1 + valueLength;

				// make already be trimmed ... avoid substring exception
				String valueStr = (controlIndex < position.length()) ? position
						.substring(secondColon + 1, controlIndex) : position
						.substring(secondColon + 1);

				Field f = getField(fieldId);
				FieldValue fv = new FieldValue(f, valueStr);
				result.put(fv);

				if (controlIndex == position.length()) {
					endOfString = true;
				} else if (controlIndex > position.length()) {
					logCat.warn("Controlbyte wrong but continuing execution");
					endOfString = true;
				} else {
					char controlByte = position.charAt(controlIndex);

					if (controlByte != '-') {
						logCat.error("Controlbyte wrong, abandon execution");
						throw new IllegalArgumentException();
					}

					startIndex = controlIndex + 1;

					if (position.length() == startIndex) {
						endOfString = true;
					}
				}
			}
		} catch (Exception e) {
			logCat.error("::getFieldValuesFromPositionAsHt - exception:", e);
			result = null;
		}

		return result;
	}

	/**
	 * Returns the vector of fields this table constists of
	 * 
	 * @return the vector of fields this table constists of
	 */
	public Vector getFields() {
		return fields;
	}

	/**
	 * Initialize the filterFieldValues array.
	 * 
	 * @param filter
	 *            the filter string
	 * @param locale
	 *            the table object
	 * 
	 * @return an initialized FieldValue array
	 * 
	 * @todo add MORE docs here !!!
	 */
	public FieldValue[] getFilterFieldArray(String filter, Locale locale) {
		if (Util.isNull(filter)) {
			return null;
		}
		// 1 to n fields may be mapped
		Vector keyValPairs = StringUtil.splitString(filter, ",;");

		// ~ no longer used as separator!
		int len = keyValPairs.size();

		FieldValue[] result = new FieldValue[len];

		for (int i = 0; i < len; i++) {
			int operator = 0;
			boolean isLogicalOR = false;
			int jump = 1;
			String aKeyValPair = (String) keyValPairs.elementAt(i);

			// i.e "id=2"
			logCat.debug("initFilterFieldValues: aKeyValPair = " + aKeyValPair);

			// Following code could be optimized, however I did not want to make
			// too many changes...
			int n;

			// Check for Not Equal
			if ((n = aKeyValPair.indexOf("<>")) != -1) {
				// Not Equal found! - Store the operation for use later on
				operator = Constants.FILTER_NOT_EQUAL;
				jump = 2;
			} else if ((n = aKeyValPair.indexOf(">=")) != -1) {
				// Check for GreaterThanEqual
				// GreaterThenEqual found! - Store the operation for use later
				// on
				operator = Constants.FILTER_GREATER_THEN_EQUAL;
				jump = 2;
			} else if ((n = aKeyValPair.indexOf('>')) != -1) {
				// Check for GreaterThan
				// GreaterThen found! - Store the operation for use later on
				operator = Constants.FILTER_GREATER_THEN;
			} else if ((n = aKeyValPair.indexOf("<=")) != -1) {
				// Check for SmallerThenEqual
				// SmallerThenEqual found! - Store the operation for use later
				// on
				operator = Constants.FILTER_SMALLER_THEN_EQUAL;
				jump = 2;
			} else if ((n = aKeyValPair.indexOf('<')) != -1) {
				// Check for SmallerThen
				// SmallerThen found! - Store the operation for use later on
				operator = Constants.FILTER_SMALLER_THEN;
			} else if ((n = aKeyValPair.indexOf('=')) != -1) {
				// Check for equal
				// Equal found! - Store the operator for use later on
				operator = Constants.FILTER_EQUAL;
			} else if ((n = aKeyValPair.indexOf('~')) != -1) {
				// Check for LIKE
				// LIKE found! - Store the operator for use later on
				operator = Constants.FILTER_LIKE;
			} else if ((n = aKeyValPair.toUpperCase().indexOf("NOTISNULL")) != -1) {
				// Check for not is null
				// LIKE found! - Store the operator for use later on
				jump = -1;
				operator = Constants.FILTER_NOT_NULL;
			} else if ((n = aKeyValPair.toUpperCase().indexOf("ISNULL")) != -1) {
				// Check for null
				// LIKE found! - Store the operator for use later on
				jump = -1;
				operator = Constants.FILTER_NULL;
			}

			// PG - At this point, I have set my operator and I should have a
			// valid index.
			// Note that the original code did not handle the posibility of not
			// finding an index
			// (value = -1)...
			String fieldName = aKeyValPair.substring(0, n).trim();

			// i.e "id"
			logCat.debug("Filter field=" + fieldName);

			if (fieldName.charAt(0) == '|') {
				// This filter must be associated to a logical OR, clean out the
				// indicator...
				fieldName = fieldName.substring(1);
				isLogicalOR = true;
			}

			Field filterField = getFieldByName(fieldName);

			// Increment by 1 or 2 depending on operator
			String value = "";
			if (jump >= 0)
				value = aKeyValPair.substring(n + jump).trim();

			// i.e. "2"
			logCat.debug("Filter value=" + value);

			// Create a new instance of FieldValue and set the operator variable
			result[i] = FieldValue.createFieldValueForSearching(filterField,
					value, locale, operator, Constants.SEARCHMODE_NONE,
					Constants.SEARCH_ALGO_SHARP, isLogicalOR);
			logCat.debug("and fv is =" + result[i].toString());
		}

		return result;
	}

	/**
	 * Get all the ForeignKey objects related to this table.
	 * 
	 * @return a vector containing all the ForeignKey objects related to this
	 *         table.
	 */
	public Collection getForeignKeys() {
		return foreignKeys;
	}

	/**
	 * Prepares the Querystring for the free form select statement
	 * 
	 * @param fieldsToSelect
	 *            vector of fields to be selected
	 * @param whereClause
	 *            free-form whereClause to be appended to query
	 * @param tableList
	 *            the list of tables involved into the query
	 * 
	 * @return the query string
	 */
	public String getFreeFormSelectQuery(Vector fieldsToSelect,
			String whereClause, String tableList) {
		StringBuffer buf = new StringBuffer();
		buf.append("SELECT ");
		buf.append(getQuerySelect(fieldsToSelect));
		buf.append(" FROM ");

		if (Util.isNull(tableList)) {
			buf.append(getQueryFrom());
		} else {
			buf.append(tableList);
		}

		buf.append(" ");
		buf.append(whereClause);
		logCat.info("::getFreeFormSelectQuery -- [" + buf.toString() + "]");

		return buf.toString();
	}

	/**
	 * Set GrantedPrivileges, if defined in dbforms-config-xml (this method gets
	 * called from XML-digester).
	 * 
	 * @param grantedPrivileges
	 *            the grantedPrivileges object
	 */
	public void setGrantedPrivileges(GrantedPrivileges grantedPrivileges) {
		this.grantedPrivileges = grantedPrivileges;
	}

	/**
	 * returns object containing info about rights mapped to user-roles.
	 * (context: this table object!)
	 * 
	 * @return the GrantedPrivileges object
	 */
	public GrantedPrivileges getGrantedPrivileges() {
		return grantedPrivileges;
	}

	/**
	 * Sets the ID of this table (this method gets called from DbFormsConfig).
	 * 
	 * @param id
	 *            the id value to set
	 */
	public void setId(int id) {
		this.id = id;
	}

	/**
	 * Returns ID of this table.
	 * 
	 * @return the id value
	 */
	public int getId() {
		return id;
	}

	/**
	 * Returns SQL insert statement, used by insertEvent.
	 * 
	 * @param fieldValues
	 *            the Hashtable containing the field values
	 * 
	 * @return the SQL insert statement
	 */
	public String getInsertStatement(FieldValues fieldValues) {
		StringBuffer queryBuf = new StringBuffer();
		queryBuf.append("INSERT INTO ");
		queryBuf.append(getQueryToChange());
		queryBuf.append(" (");

		// list the names of fields we'll include into the insert operation
		Iterator e = fieldValues.keys();
		while (e.hasNext()) {
			String fieldName = (String) e.next();
			FieldValue fv = fieldValues.get(fieldName);
			if (!isCalcField(fv.getField().getId())
					&& Util.isNull(fv.getField().getExpression())) {
				queryBuf.append(fieldName);
				if (e.hasNext()) {
					queryBuf.append(",");
				}
			}
		}

		// list the place-holders for the fields to include
		queryBuf.append(") VALUES (");
		e = fieldValues.keys();
		while (e.hasNext()) {
			String fieldName = (String) e.next();
			FieldValue fv = fieldValues.get(fieldName);
			if (!isCalcField(fv.getField().getId())
					&& Util.isNull(fv.getField().getExpression())) {
				queryBuf.append("?");
				if (e.hasNext()) {
					queryBuf.append(",");
				}
			}
		}

		queryBuf.append(")");
		logCat.info("::insertQuery - [" + queryBuf.toString() + "]");

		return queryBuf.toString();
	}

	/**
	 * Get all the interceptor objects related to this table.
	 * 
	 * @return a vector containing all the interceptor objects related to this
	 *         table.
	 */
	public Vector getInterceptors() {

		// [20050228 - fossato@pow2.com] changed this code to avoid duplicated
		// inserts of table's interceptors;
		Vector res = null;

		// has the system got any global interceptor ?
		if ((getConfig() != null) && getConfig().hasInterceptors()) {

			// insert the table's interceptors (if any) and then the global
			// interceptor(s);
			res = new Vector(interceptors);
			res.addAll(getConfig().getInterceptors());
		} else {
			res = interceptors;
		}

		return res;
	}

	/**
	 * Returns the key of this table (consisting of Field-Objects representing
	 * key-fields).
	 * 
	 * @return the key of this table (consisting of Field-Objects representing
	 *         key-fields)
	 */
	public Vector getKey() {
		return key;
	}

	/**
	 * Does basically the same as getPositionString but only for key-fields.
	 * <br>
	 * #checkme: could be merged with getPositionString <br>
	 * #fixme: replace seperator-based tokenization by better algoithm!
	 * 
	 * @param rsv
	 *            the ResultSetVector object
	 * 
	 * @return the position string for key fields
	 */
	public String getKeyPositionString(ResultSetVector rsv) {
		if (ResultSetVector.isNull(rsv)) {
			return null;
		}

		String[] currentRow = rsv.getCurrentRow();

		if (currentRow == null) {
			return null;
		}

		return getKeyPositionString(currentRow);
	}

	/**
	 * Does basically the same as getPositionString but only for key-fields.
	 * 
	 * @param currentRow
	 *            the currentRow as String[]
	 * 
	 * @return the position string
	 */
	public String getKeyPositionString(String[] currentRow) {
		StringBuffer buf = new StringBuffer();

		if (currentRow != null) {
			for (int i = 0; i < getKey().size(); i++) {
				Field f = (Field) getKey().elementAt(i);

				if (i > 0) {
					buf.append("-"); // control byte
				}

				buf.append(createToken(f, currentRow[f.getId()]));
			}
		}

		return buf.toString();
	}

	/**
	 * Get key position from the input hash table
	 * 
	 * @param fvHT
	 *            has field as key and FieldValue as value!
	 * 
	 * @return the key position string
	 * 
	 * @throws IllegalArgumentException
	 *             DOCUMENT ME!
	 */
	public String getKeyPositionString(FieldValues fvHT) {
		if (fvHT == null) {
			return null;
		}

		StringBuffer buf = new StringBuffer();
		int cnt = 0;

		for (int i = 0; i < getKey().size(); i++) {
			Field f = (Field) getKey().elementAt(i);
			FieldValue fv = fvHT.get(f.getName());

			if (fv != null) {
				String value = fv.getFieldValue();

				if (value == null) {
					throw new IllegalArgumentException("wrong fields provided");
				}

				if (cnt > 0) {
					buf.append("-"); // control byte
				}

				buf.append(createToken(f, value));
				cnt++;
			}
		}

		return buf.toString();
	}

	/**
	 * Sets the name of the table (this method gets called from XML-digester)
	 * 
	 * @param name
	 *            the name of the table
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Returns name of the table
	 * 
	 * @return the name of this table
	 */
	public String getName() {
		return name;
	}

	/**
	 * returns the hash table. Moved from dbFormTag to table, so that you can
	 * overload it!
	 * 
	 * @param core
	 *            starting tag for the fields
	 * 
	 * @return hash table of names in PHP slang we would call that an
	 *         "associative array" :=)
	 */
	public Hashtable getNamesHashtable(String core) {
		Hashtable result = new Hashtable();
		Iterator e = getFields().iterator();

		while (e.hasNext()) {
			Field f = (Field) e.next();
			result.put(f.getName(), f.getFieldName(core));
		}

		return result;
	}

	/**
	 * Sets a default-orderBy clause from xml config (this method gets called
	 * from XML-digester).
	 * 
	 * @param orderBy
	 *            the orderBy clause
	 */
	public void setOrderBy(String orderBy) {
		this.orderBy = orderBy;
	}

	/**
	 * Return default-orderBy clause from xml config or null if not specified.
	 * 
	 * @return the default-orderBy clause from xml config or null if not
	 *         specified.
	 */
	public String getOrderBy() {
		return orderBy;
	}

	/**
	 * Builds a "position- string" representing the values of the current row in
	 * the given ResultSetVector. <br>
	 * Not all field-values get explicitl listed in this string. only fields
	 * important for navigation and sorting are listed. <br>
	 * Position strings are used as request parameters allowing the framework to
	 * keep track of the position the user comes from or goes to. <br>
	 * Look into com.itp.tablib.DbFormTag for better understanding changed
	 * 0-04-2001 by joe #note: enhanced algorithm since version 0.9!
	 * 
	 * @param rsv
	 *            the ResultSetVector object
	 * 
	 * @return the position string
	 */
	public String getPositionString(ResultSetVector rsv) {
		if (ResultSetVector.isNull(rsv)) {
			return null;
		}

		String[] currentRow = rsv.getCurrentRow();

		if (currentRow == null) {
			return null;
		}

		return getPositionString(currentRow);
	}

	/**
	 * Builds a "position- string" representing the values of the current row in
	 * the given ResultSetVector. <br>
	 * Not all field-values get explicitly listed in this string. only fields
	 * important for navigation and sorting are listed. <br>
	 * Position strings are used as request parameters allowing the framework to
	 * keep track of the position the user comes from or goes to. <br>
	 * 
	 * @param currentRow
	 *            the currentRow as String[]
	 * 
	 * @return the position string
	 */
	public String getPositionString(String[] currentRow) {
		StringBuffer buf = new StringBuffer();
		int cnt = 0;

		for (int i = 0; i < getFields().size(); i++) {
			Field f = (Field) getFields().elementAt(i);

			if (f.hasIsKeySet() || f.hasSortableSet()) {
				if (cnt > 0) {
					buf.append("-"); // control byte
				}

				buf.append(createToken(f, currentRow[f.getId()]));
				cnt++;
			}
		}

		return buf.toString();
	}

	/**
	 * Used for instance by goto with prefix
	 * 
	 * @param ht
	 *            the Hashtable object containing the field names used to build
	 *            the position string ht has fieldName as key and valueStr as
	 *            value!
	 * 
	 * @return the position string
	 */
	public String getPositionString(Hashtable ht) {
		StringBuffer buf = new StringBuffer();
		int cnt = 0;
		Iterator e = ht.keySet().iterator();

		while (e.hasNext()) {
			String fieldName = (String) e.next();
			Field aField = getFieldByName(fieldName);

			if (aField != null) {
				if (aField.hasIsKeySet() || aField.hasSortableSet()) {
					String fieldValue = (String) ht.get(fieldName);

					if (cnt > 0) {
						buf.append('-'); // control byte
					}

					buf.append(createToken(aField, fieldValue));
					cnt++;
				} else {
					logCat.debug("provided goto field " + fieldName
							+ " is not key/search field!");
				}
			} else {
				logCat
						.error("provided goto field " + fieldName
								+ " not found!");
			}
		}

		return buf.toString();
	}

	/**
	 * Get key position from the input hash table
	 * 
	 * @param fvHT
	 *            has field as key and FieldValue as value!
	 * 
	 * @return the key position string
	 * 
	 * @throws IllegalArgumentException
	 *             DOCUMENT ME!
	 */
	public String getPositionString(FieldValues fvHT) {
		String res = null;
		if (fvHT != null) {
			StringBuffer buf = new StringBuffer();
			int cnt = 0;
			Iterator e = fvHT.keys();

			while (e.hasNext()) {
				String fieldName = (String) e.next();
				FieldValue fv = fvHT.get(fieldName);
				Field f = fv.getField();

				if (f.hasIsKeySet() || f.hasSortableSet()) {
					String value = fv.getFieldValue();

					if (value == null) {
						throw new IllegalArgumentException(
								"wrong fields provided");
					}

					if (cnt > 0) {
						buf.append("-"); // control byte
					}

					buf.append(createToken(f, value));
					cnt++;
				}
			}

			res = buf.toString();
		}
		return res;
	}

	/**
	 * Returns the FROM part of a query.
	 * 
	 * @return the FROM part of a query
	 */
	public String getQueryFrom() {
		String res = getAlias();
		if (Util.isNull(res)) {
			res = name;
		}
		return res;
	}

	/**
	 * Returns the select part of a query.
	 * 
	 * @param fieldsToSelect
	 *            the vector containing the Field objects used to build the
	 *            elect part of the query
	 * 
	 * @return the select part of a query
	 */
	public String getQuerySelect(Vector fieldsToSelect) {
		if (fieldsToSelect != null) {
			StringBuffer buf = new StringBuffer();
			int fieldsToSelectSize = fieldsToSelect.size();

			// #checkme: do i need this when using Hotspot ?
			// we scroll through vector directly (no enumeration!)
			// to maintain correct order of elements
			for (int i = 0; i < fieldsToSelectSize; i++) {
				Field f = (Field) fieldsToSelect.elementAt(i);
				buf.append(f.getName());
				buf.append(", ");
			}

			buf.deleteCharAt(buf.length() - 2);

			return buf.toString();
		}

		return "*";
	}

	/**
	 * Prepares the Querystring for the select statement Order of parts: 1.
	 * sqlFilter (fild in getDoSelectResultSet!) 2. where condition generated
	 * from having / ordering fields (fild in populateWhereEqualsClause)
	 * Retrieving the parameters in getDoSelectResultSet() must match this
	 * order!
	 * 
	 * @param fieldsToSelect
	 *            vector of fields to be selected
	 * @param fvEqual
	 *            fieldValues representing values we are looking for
	 * @param fvOrder
	 *            fieldValues representing needs for order clauses
	 * @param sqlFilter
	 *            sql condition to and with the where clause
	 * @param compareMode
	 *            compare mode value for generating the order clause
	 * 
	 * @return the query string
	 */
	public String getSelectQuery(Vector fieldsToSelect, FieldValue[] fvEqual,
			FieldValue[] fvOrder, String sqlFilter, int compareMode) {
		StringBuffer buf = new StringBuffer();

		buf.append("SELECT ");
		buf.append(getQuerySelect(fieldsToSelect));
		buf.append(" FROM ");
		buf.append(getQueryFrom());

		String s = getQueryWhere(fvEqual, fvOrder, compareMode);

		if (!Util.isNull(s) || !Util.isNull(sqlFilter)) {
			buf.append(" WHERE ");
		}

		// where condition from DbFormTag's sqlFilter attribute
		if (!Util.isNull(sqlFilter)) {
			buf.append(" ( ");
			buf.append(sqlFilter);
			buf.append(" ) ");
		}

		// where condition generated from searching / ordering
		if (!Util.isNull(s)) {
			if (!Util.isNull(sqlFilter)) {
				buf.append(" AND ");
			}

			buf.append(" ( ");
			buf.append(s);
			buf.append(" ) ");
		}

		s = getQueryOrderBy(fvOrder);

		if (s.length() > 0) {
			buf.append(" ORDER BY ");
			buf.append(s);
		}

		logCat.info("::getSelectQuery - [" + buf.toString() + "]");

		return buf.toString();
	}

	// ------------------------------ SQL methods
	// ---------------------------------

	/**
	 * Get the SQL select statement.
	 * 
	 * @return the SQL select statement
	 */
	public String getSelectStatement() {
		StringBuffer queryBuf = new StringBuffer();
		queryBuf.append("SELECT ");
		queryBuf.append(getQuerySelect(fields));
		queryBuf.append(" FROM ");
		queryBuf.append(getQueryFrom());
		logCat.info(queryBuf.toString());

		return queryBuf.toString();
	}

	/**
	 * Set the table events object related to this table.
	 * 
	 * @param tableEvents
	 *            the table events object related to this table
	 */
	public void setTableEvents(TableEvents tableEvents) {
		this.tableEvents = tableEvents;
		tableEvents.setTable(this);
	}

	/**
	 * Get the table events object related to this table. <br>
	 * If it is null (because user didn't specify custom events), set a new
	 * TableEvents object and return its reference.
	 * 
	 * @return the table events object related to this table
	 */
	public TableEvents getTableEvents() {
		if (tableEvents == null) {
			tableEvents = new TableEvents();
		}

		return tableEvents;
	}

	/**
	 * Returns SQL update statement, used by updateEvent.
	 * 
	 * @param fieldValues
	 *            the Hashtable object containing the field values
	 * 
	 * @return the SQL update statement
	 */
	public String getUpdateStatement(FieldValues fieldValues, String keyValStr) {
		StringBuffer queryBuf = new StringBuffer();
		queryBuf.append("UPDATE ");
		queryBuf.append(getQueryToChange());
		queryBuf.append(" SET ");

		// list the names of fields and the place holder for their new values
		// important: these are the fields which are sent through the current
		// request;
		// this list may be only a subset of the field list,
		// it is not necessarily the complete field list of a table!
		boolean kommaNeeded = false;
		Iterator e = fieldValues.keys();
		while (e.hasNext()) {
			String fieldName = (String) e.next();
			FieldValue fv = fieldValues.get(fieldName);
			if (!isCalcField(fv.getField().getId())
					&& Util.isNull(fv.getField().getExpression())) {
				if (kommaNeeded) {
					queryBuf.append(", ");
				} else {
					kommaNeeded = true;
				}
				queryBuf.append(fieldName);
				queryBuf.append("= ?");
			}
		}
		queryBuf.append(" WHERE ");
		queryBuf.append(getWhereClauseForKeyFields(keyValStr));
		logCat.info("::updateQuery - [" + queryBuf.toString() + "]");

		return queryBuf.toString();
	}

	/**
	 * Build the WHERE clause string using the input field values.
	 * 
	 * @param fv
	 *            the array of FieldValue objects
	 * 
	 * @return the WHERE clause string protected so that it can be tested
	 */
	public String getWhereClause(FieldValue[] fv) {
		StringBuffer buf = new StringBuffer();

		if ((fv != null) && (fv.length > 0)) {
			// SM 2003-08-08: added brackets for each and-ed condition
			buf.append(" ( ");

			for (int i = 0; i < fv.length; i++) {
				// depending on the value of isLogicalOR in FieldValue,
				// prefix the filter definition with either OR or AND
				// (Skip first entry!)
				if (i != 0) {
					if (fv[i].getLogicalOR()) {
						buf.append(" OR ");
					} else {
						buf.append(" ) AND ( ");
					}
				}

				buf.append(getSQLExpression(fv[i]));
			}

			buf.append(" ) ");
		}

		return buf.toString();
	}

	// ----------------- some convenience methods
	// ---------------------------------------------

	/**
	 * Generates a part of the SQL where clause needed to select a distinguished
	 * row form the table. This is done by querying for KEY VALUES !
	 * 
	 * @return a part of the SQL where clause needed to select a distinguished
	 *         row form the table
	 */
	public String getWhereClauseForKeyFields(String keyValuesStr) {
		StringBuffer buf = new StringBuffer();
		FieldValues keyValuesHt = getFieldValues(keyValuesStr);

		int cnt = this.getKey().size();

		for (int i = 0; i < cnt; i++) {
			Field keyField = (Field) this.getKey().elementAt(i);

			FieldValue aFieldValue = keyValuesHt.get(keyField.getName());
			Object value = aFieldValue.getFieldValueAsObject();
			// get the name of the encoded key field
			buf.append(keyField.getName());
			if (value == null) {
				buf.append(" is null");
			} else {
				buf.append(" = ?");
			}
			if (i < (cnt - 1)) {
				buf.append(" AND ");
			}
		}

		return buf.toString();
	}

	/**
	 * adds a Field-Object to this table and puts it into othere datastructure
	 * for further references (this method gets called from DbFormsConfig)
	 * 
	 * @param field
	 *            field to add
	 * 
	 * @throws Exception
	 *             DOCUMENT ME!
	 */
	public void addCalcField(Field field) throws Exception {
		field.setId(encodeFieldId(CALC_FIELD, calcFields.size()));
		field.setTable(this);
		calcFields.addElement(field);

		// for quicker lookup by name:
		calcFieldsNameHash.put(field.getName(), field);
	}

	/**
	 * Adds a Field-Object to this table and puts it into othere datastructure
	 * for further references (this method gets called from DbFormsConfig)
	 * 
	 * @param field
	 *            the Field object to add
	 * 
	 * @throws Exception
	 *             DOCUMENT ME!
	 */
	public void addField(Field field) throws Exception {
		if (field.getType() == 0) {
			throw new Exception("Table " + getName() + " Field "
					+ field.getName() + ": no type!");
		}

		field.setId(encodeFieldId(DB_FIELD, fields.size()));
		field.setTable(this);
		fields.addElement(field);

		// if the field is (part of) the key
		if (field.hasIsKeySet()) {
			logCat.info("wow - field " + getName() + "." + field.getName()
					+ " is a key");
			// use key not getKey! getKey will return key Vector of parent
			// table in case of query!
			key.addElement(field);
		} else {
			logCat.info("field " + getName() + "." + field.getName()
					+ " is NO key");
		}

		// for quicker lookup by name:
		fieldNameHash.put(field.getName(), field);

		// for quicker check for diskblobs
		if (field.getType() == FieldTypes.DISKBLOB) {
			diskblobs.addElement(field);
		}
	}

	/**
	 * Adds a ForeignKey-Object to this table and puts it into othere
	 * datastructure for further references (this method gets called from
	 * DbFormsConfig)
	 * 
	 * @param fk
	 *            the foreign key object
	 */
	public void addForeignKey(ForeignKey fk) {
		fk.setId(foreignKeys.size());

		// add to vector containing all foreign keys:
		foreignKeys.addElement(fk);

		// for quicker lookup by name:
		foreignKeyNameHash.put(fk.getName(), fk);
	}

	/**
	 * Add an interceptor to this table.
	 * 
	 * @param interceptor
	 *            the interceptor to add
	 */
	public void addInterceptor(Interceptor interceptor) {
		interceptors.addElement(interceptor);
	}

	/**
	 * Determinates if this table contains a diskblob field. (this method is
	 * used by DeleteEvent which needs to delete files referenced by a diskblob
	 * field).
	 * 
	 * @return true if this table contains a diskblob field, false otherwise
	 */
	public boolean containsDiskblob() {
		return diskblobs.size() > 0;
	}

	/**
	 * Column ["ASC" | "DESC"] {"," Column ["ASC" | "DESC"] } (if neither ASC
	 * nor DESC follow "Col", then ASC is choosen as default). <br>
	 * this method assures, that ALL KEY FIELDs are part of the order criteria,
	 * in any case (independly from the order-Str). if necessary it appends
	 * them. WHY: to ensure correct scrollig (not getting STUCK if the search
	 * criteria are not "sharp" enough). <br>
	 * #fixme - better explaination #fixme - determinate illegal input and throw
	 * IllegalArgumentException
	 * 
	 * @param order
	 *            a String from JSP provided by the user in SQL-Style
	 * @param request
	 *            the request object
	 * @param includeKeys
	 *            true to include key fields, false otherwise
	 * 
	 * @return ???
	 */
	public FieldValue[] createOrderFieldValues(String order,
			HttpServletRequest request, boolean includeKeys) {
		Vector result = null;

		if (request != null) {
			String paramStub = Constants.FIELDNAME_SORT + this.getId();
			Vector sortFields = ParseUtil.getParametersStartingWith(request,
					paramStub);

			if (sortFields.size() > 0) {
				result = createOrderFVFromRequest(request, paramStub,
						sortFields);
			}
		}

		// 20020703-HKK: use the default order if result.size == 0, not only if
		// result == null
		// This happens if all parameters with sort_ are set to none
		if (((result == null) || result.isEmpty())) {
			// 20021104-HKK: use default order from table if form has no order!
			if (order == null) {
				order = getOrderBy();
			}

			result = createOrderFVFromAttribute(order);
			logCat.debug("@@@ 1");

			for (int i = 0; i < result.size(); i++) {
				FieldValue fieldVal = (FieldValue) result.elementAt(i);
				logCat.debug("fieldValue " + fieldVal.toString());
			}
		}

		if (includeKeys) {
			// scroll through keys and append to order criteria, if not already
			// included
			for (int i = 0; i < this.getKey().size(); i++) {
				Field keyField = (Field) getKey().elementAt(i);
				boolean found = false;
				int j = 0;

				while (!found && (j < result.size())) {
					FieldValue fv = (FieldValue) result.elementAt(j);

					if (fv.getField() == keyField) {
						found = true;
					}

					j++;
				}

				if (!found) {
					result.addElement(FieldValue.createFieldValueForSorting(
							keyField, Constants.ORDER_ASCENDING));
				}
			}
		}

		FieldValue[] resultArray = new FieldValue[result.size()];
		result.copyInto(resultArray);
		logCat.debug("@@@ 2");

		for (int i = 0; i < resultArray.length; i++) {
			logCat.debug("fieldValue " + resultArray[i].toString());
		}

		return resultArray;
	}

	// ------------------------------ Old ResultSetVector stuff
	// ---------------------------------

	/**
	 * Do a constrained select.
	 * 
	 * @param fvEqual
	 *            FieldValue array used to restrict a set in a subform where all
	 *            "childFields" in the resultset match their respective
	 *            "parentFields" in main form
	 * @param fvOrder
	 *            FieldValue array used to build a cumulation of rules for
	 *            ordering (sorting) and restricting fields
	 * @param sqlFilter
	 *            sql condition to add to where clause
	 * @param sqlFilterParams
	 *            DOCUMENT ME!
	 * @param compareMode
	 *            the value of the compare mode
	 * @param maxRows
	 *            the max number of rows to manage
	 * @param interceptorData
	 *            the connection object
	 * 
	 * @return a ResultSetVector object
	 * 
	 * @throws SQLException
	 *             if any error occurs
	 */
	public ResultSetVector doConstrainedSelect(FieldValue[] fvEqual,
			FieldValue[] fvOrder, String sqlFilter,
			FieldValue[] sqlFilterParams, int compareMode, int maxRows,
			DbEventInterceptorData interceptorData) throws SQLException {
		String query = getSelectQuery(getFields(), fvEqual, fvOrder, sqlFilter,
				compareMode);
		PreparedStatement ps = interceptorData.getConnection()
				.prepareStatement(query);
		ps.setMaxRows(maxRows); // important when quering huge tables

		ResultSet rs = getDoSelectResultSet(fvEqual, fvOrder, sqlFilterParams,
				compareMode, ps);
		ResultSetVector result = new ResultSetVector(this);
		result.addResultSet(interceptorData, rs);
		ps.close();
		logCat.info("::doConstrainedSelect - rsv size = " + result.size());

		return result;
	}

	/**
	 * perform free-form select query
	 * 
	 * @param whereClause
	 *            free-form whereClause to be appended to query
	 * @param tableList
	 *            the list of tables involved into the query
	 * @param maxRows
	 *            how many rows should be stored in the resultSet (zero means
	 *            unlimited)
	 * @param interceptorData
	 *            the active db connection to use
	 * 
	 * @return the ResultSetVector object
	 * 
	 * @throws SQLException
	 *             if any error occurs
	 */
	public ResultSetVector doFreeFormSelect(String whereClause,
			String tableList, int maxRows,
			DbEventInterceptorData interceptorData) throws SQLException {
		Statement stmt = interceptorData.getConnection().createStatement();
		String query = getFreeFormSelectQuery(getFields(), whereClause,
				tableList);
		stmt.setMaxRows(maxRows); // important when quering huge tables

		ResultSet rs;

		try {
			rs = stmt.executeQuery(query);
		} catch (SQLException sqle) {
			SqlUtil.logSqlException(sqle);
			throw new SQLException(sqle.getMessage());
		}

		ResultSetVector result = new ResultSetVector(this);
		result.addResultSet(interceptorData, rs);

		// 20021115-HKK: resultset is closed in ResultSetVector()
		// rs.close();
		stmt.close();
		logCat.info("rsv size=" + result.size());

		return result;
	}

	/**
	 * in version 0.9 this method moved from FieldValue.fillWithValues to
	 * Table.fillWithValues
	 * 
	 * @param orderConstraint
	 *            FieldValue array used to build a cumulation of rules for
	 *            ordering (sorting) and restricting fields
	 * @param aPosition
	 *            resultset position
	 */
	public void fillWithValues(FieldValue[] orderConstraint, String aPosition) {
		// 2003-03-29 HKK: Change from Hashtable to FieldValueTable
		FieldValues ht = getFieldValues(aPosition);

		// 20021104-HKK: Error handling if aPosition is not given!
		if (ht != null) {
			logCat.info("*** parsing through: " + aPosition);

			// then we copy some of those values into the orderConstraint
			for (int i = 0; i < orderConstraint.length; i++) {
				Field f = orderConstraint[i].getField();

				if (f != null) {
					FieldValue aFieldValue = ht.get(f.getName());

					if (aFieldValue != null) {
						orderConstraint[i].setFieldValue(aFieldValue
								.getFieldValue());
					} else {
						logCat.warn("position entry has null value:"
								+ f.getName());
					}
				}
			}
		}
	}

	/**
	 * Check if this table has got interceptors.
	 * 
	 * @return true if the table contains interceptors, false otherwise
	 */
	public boolean hasInterceptors() {
		return (getConfig() != null && getConfig().hasInterceptors())
				|| ((interceptors != null) && (interceptors.size() > 0));
	}

	/**
	 * Checks if there exists a granted-privileges object and if so it queries
	 * if access/operation is possible
	 * 
	 * @param request
	 *            the request object
	 * @param privileg
	 *            the privilege value
	 * 
	 * @return true if the user has got privileges over this table, false
	 *         otherwise
	 */
	public boolean hasUserPrivileg(HttpServletRequest request, int privileg) {
		return (grantedPrivileges == null) ? true : grantedPrivileges
				.hasUserPrivileg(request, privileg);
	}

	/**
	 * This method generates a datastructure holding sorting information from
	 * "orderBy" clause in XML-config.
	 */
	public void initDefaultOrder() {
		// if developer specified no orderBy in XML, then we set the KEYs as
		// DEFAULT ORDER
		if (orderBy == null) {
			initDefaultOrderFromKeys();
		} else {
			// build the datastructure, containing Fields, and infos about sort
			defaultOrder = createOrderFieldValues(orderBy, null, true);
		}

		logCat.info("Table.initDefaultOrder done.");
	}

	/**
	 * maps child fields to parent fields
	 * 
	 * @param parentTable
	 *            the parent table
	 * @param parentFieldString
	 *            field names in parent table
	 * @param childFieldString
	 *            field names in child table
	 * @param aPosition
	 *            position to map as position string
	 * 
	 * @return FieldValues with result
	 * 
	 * @throws IllegalArgumentException
	 *             DOCUMENT ME!
	 */
	public FieldValues mapChildFieldValues(Table parentTable,
			String parentFieldString, String childFieldString, String aPosition) {
		// 1 to n fields may be mapped
		Vector childFieldNames = StringUtil
				.splitString(childFieldString, ",;~");
		Vector parentFieldNames = StringUtil.splitString(parentFieldString,
				",;~");

		// do some basic checks
		// deeper checks like Datatyp-compatibility,etc not done yet
		int len = childFieldNames.size();

		if ((len == 0) || (len != parentFieldNames.size())) {
			return null;
		}

		// 2003-03-29 HKK: Change from Hashtable to FieldValueTable
		FieldValues ht = parentTable.getFieldValues(aPosition);

		if (ht == null) {
			return null;
		}

		FieldValues childFieldValues = new FieldValues();

		for (int i = 0; i < len; i++) {
			String parentFieldName = (String) parentFieldNames.elementAt(i);
			Field parentField = parentTable.getFieldByName(parentFieldName);
			String childFieldName = (String) childFieldNames.elementAt(i);
			Field childField = this.getFieldByName(childFieldName);
			FieldValue aFieldValue = ht.get(parentField.getName());

			if (aFieldValue == null) {
				throw new IllegalArgumentException(
						"ERROR: Make sure that field "
								+ parentField.getName()
								+ " is a KEY of the table "
								+ parentTable.getName()
								+ "! Otherwise you can not use it as PARENT/CHILD LINK argument!");
			}

			String currentParentFieldValue = aFieldValue.getFieldValue();
			childFieldValues.put(new FieldValue(childField,
					currentParentFieldValue));
		}

		return childFieldValues;
	}

	/**
	 * POPULATES a part of the SQL where clause needed to select a distinguished
	 * row form the table using values endcoded in a string. <br>
	 * #fixme: replace seperator-based tokenization by better algoithm!
	 * 
	 * @param keyValuesStr
	 *            the position string
	 * @param ps
	 *            the PreparedStatement object
	 * @param startColumn
	 *            PreparedStatement start column
	 * 
	 * @throws SQLException
	 *             if any error occurs
	 */
	public void populateWhereClauseWithKeyFields(String keyValuesStr,
			PreparedStatement ps, int startColumn) throws SQLException {
		int col = startColumn;

		// then we list the values of the key-fields, so that the WHERE clause
		// matches the right dataset
		// 2003-03-29 HKK: Change from Hashtable to FieldValueTable
		FieldValues keyValuesHt = getFieldValues(keyValuesStr);
		int keyLength = this.getKey().size();

		for (int i = 0; i < keyLength; i++) {
			Field curField = (Field) this.getKey().elementAt(i);
			FieldValue aFieldValue = keyValuesHt.get(curField.getName());
			Object value = aFieldValue.getFieldValueAsObject();
			if (value != null) {
				JDBCDataHelper.fillWithData(ps, curField.getEscaper(), col,
						value, curField.getType(), this
								.getBlobHandlingStrategy());
				col++;
			}
		}
	}

	/**
	 * situation: we have built a query (involving the getWhereEqualsClause()
	 * method) and now we want to prepare the statemtent - provide actual values
	 * for the the '?' placeholders
	 * 
	 * @param fv
	 *            the array of FieldValue objects
	 * @param ps
	 *            the PreparedStatement object
	 * @param curCol
	 *            the current PreparedStatement column; points to a
	 *            PreparedStatement xxx value
	 * 
	 * @return the current column value
	 * 
	 * @exception SQLException
	 *                if any error occurs
	 */
	public int populateWhereEqualsClause(FieldValue[] fv, PreparedStatement ps,
			int curCol) throws SQLException {
		if ((fv != null) && (fv.length > 0)) {
			for (int i = 0; i < fv.length; i++) {
				curCol = fillPreparedStatement(fv[i], ps, curCol);
			}
		}

		return curCol;
	}

	/**
	 * Process the interceptor objects related to this table.
	 * 
	 * @param action
	 *            the DbEventInterceptor identifier. See the DbEventInterceptor
	 *            class for the real values. Example:
	 *            <code>DbEventInterceptor.PRE_UPDATE</code>
	 * @param data
	 *            the DbEventInterceptorData object
	 * 
	 * @return the value that identifies if an operation should be granted,
	 *         denied or ignored. See
	 *         <code>DbEventInterceptor.GRANT_OPERATION</code>,
	 *         <code>DbEventInterceptor.DENY_OPERATION</code>,
	 *         <code>DbEventInterceptor.IGNORE_OPERATION</code>
	 * 
	 * @throws SQLException
	 *             if any error occurs
	 */
	public int processInterceptors(int action, DbEventInterceptorData data)
			throws MultipleValidationException {
		String s;
		try {
			Vector allInterceptors = getInterceptors();
			int interceptorsCnt = allInterceptors.size();

			for (int i = 0; i < interceptorsCnt; i++) {
				Interceptor interceptor = (Interceptor) allInterceptors
						.elementAt(i);
				IDbEventInterceptor dbi = (IDbEventInterceptor)ReflectionUtil.newInstance(interceptor.getClassName());

				// J.Peer 03/18/2004 - plug in some additional config data for
				// interceptor
				dbi.setParameterMap(interceptor.getParameterMap());

				// (Sunil_Mishra@adp.com) - The return type to check for the
				// IGNORE_OPERATION
				int operation = IDbEventInterceptor.GRANT_OPERATION;
				String denyMessage = null;

				if (action == IDbEventInterceptor.PRE_INSERT) {
					operation = dbi.preInsert(data);
					denyMessage = "dbforms.events.insert.nogrant";
				} else if (action == IDbEventInterceptor.POST_INSERT) {
					dbi.postInsert(data);
				} else if (action == IDbEventInterceptor.PRE_UPDATE) {
					operation = dbi.preUpdate(data);
					denyMessage = "dbforms.events.update.nogrant";
				} else if (action == IDbEventInterceptor.POST_UPDATE) {
					dbi.postUpdate(data);
				} else if (action == IDbEventInterceptor.PRE_DELETE) {
					operation = dbi.preDelete(data);
					denyMessage = "dbforms.events.delete.nogrant";
				} else if (action == IDbEventInterceptor.POST_DELETE) {
					dbi.postDelete(data);
				} else if (action == IDbEventInterceptor.PRE_SELECT) {
					operation = dbi.preSelect(data);
					denyMessage = "dbforms.events.view.nogrant";
				} else if (action == IDbEventInterceptor.POST_SELECT) {
					dbi.postSelect(data);
				} else if (action == IDbEventInterceptor.PRE_ADDROW) {
					operation = dbi.preAddRow(data);
					denyMessage = "dbforms.events.addrow.nogrant";
				} else if (action == IDbEventInterceptor.POST_ADDROW) {
					dbi.postAddRow(data);
				}

				switch (operation) {
				case IDbEventInterceptor.DENY_OPERATION:
					s = MessageResourcesInternal.getMessage(denyMessage, data
							.getRequest().getLocale(),
							new String[] { getName() });
					throw new MultipleValidationException(s);

				case IDbEventInterceptor.IGNORE_OPERATION:
					return operation;

				default:
					break;
				}
			}
		} catch (ClassNotFoundException cnfe) {
			logCat.warn("ClassNotFoundException: " + cnfe.getMessage());
			throw new MultipleValidationException(cnfe.getMessage());
		} catch (InstantiationException ie) {
			logCat.warn(" InstantiationException : " + ie.getMessage());
			throw new MultipleValidationException(ie.getMessage());
		} catch (IllegalAccessException iae) {
			logCat.warn(" IllegalAccessException : " + iae.getMessage());
			throw new MultipleValidationException(iae.getMessage());
		} catch (MultipleValidationException mve) {
			throw mve;
		} catch (ValidationException ve) {
			throw new MultipleValidationException(ve.getMessage());
		}

		return IDbEventInterceptor.GRANT_OPERATION;
	}

	// ------------------------------ utility / helper methods
	// ---------------------------------

	/**
	 * This metod is useful for logging / debugging purposes only.
	 * 
	 * @return a string containing the Table name and field values
	 */
	public String toString() {
		StringBuffer buf = new StringBuffer();
		buf.append("\nname=");
		buf.append(name);
		buf.append(" ");
		buf.append("\nid=");
		buf.append(String.valueOf(getId()));
		buf.append(" ");

		if (getFields() != null) {
			for (int i = 0; i < getFields().size(); i++) {
				Field f = (Field) getFields().elementAt(i);
				buf.append("\nfield: ");
				buf.append(f.toString());
			}
		}

		return buf.toString();
	}

	/**
	 * Returns the part of the orderby-clause represented by this FieldValue
	 * object. <br>
	 * (ASC will be not printed because it is defined DEFAULT in SQL if there
	 * are RDBMS which do not tolerate this please let me know; then i'll change
	 * it).
	 * 
	 * @param fvOrder
	 *            FieldValue array used to build a cumulation of rules for
	 *            ordering (sorting) and restricting fields
	 * 
	 * @return the part of the orderby-clause represented by this FieldValue
	 *         object
	 */
	protected String getQueryOrderBy(FieldValue[] fvOrder) {
		StringBuffer buf = new StringBuffer();

		if (fvOrder != null) {
			for (int i = 0; i < fvOrder.length; i++) {
				buf.append(fvOrder[i].getField().getName());

				if (fvOrder[i].getSortDirection() == Constants.ORDER_DESCENDING) {
					buf.append(" DESC");
				}

				if (i < (fvOrder.length - 1)) {
					buf.append(",");
				}
			}
		}

		return buf.toString();
	}

	/**
	 * Returns the FROM part of a insert/delete/update query.
	 * 
	 * @return the FROM part of a insert/delete/update query
	 */
	protected String getQueryToChange() {
		return getQueryFrom();
	}

	/**
	 * Returns the WHERE part of a query.
	 * 
	 * @param fvEqual
	 *            FieldValue array used to restrict a set in a subform where all
	 *            "childFields" in the resultset match their respective
	 *            "parentFields" in main form
	 * @param fvOrder
	 *            FieldValue array used to build a cumulation of rules for
	 *            ordering (sorting) and restricting fields
	 * @param compareMode
	 *            compare mode value for generating the order clause
	 * 
	 * @return the WHERE part of a query
	 */
	protected String getQueryWhere(FieldValue[] fvEqual, FieldValue[] fvOrder,
			int compareMode) {
		boolean firstTermExists = false;
		StringBuffer buf = new StringBuffer();

		// build the first term;
		if (!FieldValue.isNull(fvEqual)) {
			// check if the fieldvalues contain _search_ information
			buf.append(" ( ");

			if (fvEqual[0].getSearchMode() == Constants.SEARCHMODE_NONE) {
				buf.append(getWhereClause(fvEqual));
			} else {
				buf.append(getWhereEqualsSearchClause(fvEqual));
			}

			buf.append(" ) ");
			firstTermExists = true;
		}

		// build the second term;
		// this SHOULD be the WHERE clause which restricts
		// the query to rows coming AFTER the row containing the actual data.
		if (!FieldValue.isNull(fvOrder)
				&& (compareMode != Constants.COMPARE_NONE)) {
			buf.append(firstTermExists ? " AND ( " : "");
			buf.append(getWhereAfterClause(fvOrder, compareMode));
			buf.append(firstTermExists ? " ) " : "");
		}

		return buf.toString();
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @param type
	 *            DOCUMENT ME!
	 * @param id
	 *            DOCUMENT ME!
	 * 
	 * @return DOCUMENT ME!
	 */
	protected boolean checkFieldId(int type, int aid) {
		int i = aid / MAXFIELDS;
		return i == type;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @param type
	 *            DOCUMENT ME!
	 * @param id
	 *            DOCUMENT ME!
	 * 
	 * @return DOCUMENT ME!
	 */
	protected int decodeFieldId(int type, int aid) {
		return aid - (type * MAXFIELDS);
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @param type
	 *            DOCUMENT ME!
	 * @param id
	 *            DOCUMENT ME!
	 * 
	 * @return DOCUMENT ME!
	 */
	protected int encodeFieldId(int type, int aid) {
		return (type * MAXFIELDS) + aid;
	}

	/**
	 * returns an SQLExpression based on the given FieldValue
	 * 
	 * @param fv
	 *            the FieldValue
	 * 
	 * @return string holding the SQL Expression
	 */
	private String getSQLExpression(FieldValue fv) {
		StringBuffer buf = new StringBuffer();

		// 20021104-HKK: Check for expression.
		Field f = fv.getField();
		String fieldName = Util.isNull(f.getExpression()) ? f.getName() : f
				.getExpression();
		buf.append(fieldName);

		// Check what type of operator is required
		switch (fv.getOperator()) {
		case Constants.FILTER_EQUAL:
			buf.append(" = ");
			buf.append(" ? ");

			break;

		case Constants.FILTER_NOT_EQUAL:
			buf.append(" <> ");
			buf.append(" ? ");

			break;

		case Constants.FILTER_GREATER_THEN:
			buf.append(" > ");
			buf.append(" ? ");

			break;

		case Constants.FILTER_SMALLER_THEN:
			buf.append(" < ");
			buf.append(" ? ");

			break;

		case Constants.FILTER_GREATER_THEN_EQUAL:
			buf.append(" >= ");
			buf.append(" ? ");

			break;

		case Constants.FILTER_SMALLER_THEN_EQUAL:
			buf.append(" <= ");
			buf.append(" ? ");

			break;

		case Constants.FILTER_LIKE:

			if (FieldTypes.isCHAR(f.getType())) {
				buf.append(" LIKE ");
			} else {
				buf.append(" = ");
			}

			buf.append(" ? ");

			break;

		case Constants.FILTER_NULL:
			buf.append(" IS NULL ");

			break;

		case Constants.FILTER_NOT_NULL:
			buf.append(" IS NOT NULL ");

			break;

		case Constants.FILTER_EMPTY:

			if (FieldTypes.isCHAR(f.getType())) {
				buf.append(" = '' ");
				buf.append(" OR ");
			}

			buf.append(fieldName);
			buf.append(" IS NULL ");

			break;

		case Constants.FILTER_NOT_EMPTY:

			if (FieldTypes.isCHAR(f.getType())) {
				buf.append(" <> '' ");
				buf.append(" OR ");
			}

			buf.append(fieldName);
			buf.append(" IS NOT NULL ");

			break;
		}

		return buf.toString();
	}

	/**
	 * situation: we have an array of fieldvalues which represents actual values
	 * of order-determinating-fields. we want to build a part of the WHERE
	 * clause which restricts the query to rows coming AFTER the row containing
	 * the actual data. <br>
	 * shortly described the following rule is applied:
	 * 
	 * <pre>
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *            +--------------------------------------------------------------------------------------------------+
	 *            |  RULE = R1 AND R2 AND ... AND Rn                                                                 |
	 *            |  Ri = fi OpA(i) fi* OR  f(i-1) OpB(i-1) f(i-1)* OR f(i-2) OpB(i-2) f(i-2)* OR ... OR f1 OpB f1*  |
	 *            +--------------------------------------------------------------------------------------------------+
	 *            For background info email joepeer@wap-force.net
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 * </pre>
	 * 
	 * IMPORTANT NOTE: the indizes of the fv-array indicate implicitly the
	 * order-priority of the fields. <br>
	 * example: if we have ORDER BY id,name,age -> then fv[0] should contain
	 * field id, fv[1] should contain field name, fv[2] should contain field age
	 * 
	 * @param fv
	 *            the array of FieldValue objects
	 * @param compareMode
	 *            the comparison mode
	 * 
	 * @return _part_ of a WHERE-clause
	 */
	private String getWhereAfterClause(FieldValue[] fv, int compareMode) {
		String conj;
		String disj;
		String opA1;
		String opA2;
		String opB1;
		String opB2;

		// COMPARE_INCLUSIVE
		if (compareMode == Constants.COMPARE_INCLUSIVE) {
			opA1 = ">=";
			opA2 = "<=";
			opB1 = ">";
			opB2 = "<";
			conj = " AND ";
			disj = " OR ";
		} else {
			opA1 = ">";
			opA2 = "<";
			opB1 = ">=";
			opB2 = "<=";
			conj = " OR ";
			disj = " AND ";
		}

		StringBuffer buf = new StringBuffer();

		if ((fv != null) && (fv.length > 0)) {
			// generate the Ri's
			for (int i = 0; i < fv.length; i++) {
				// generate a "fi OpA(i) fi*"
				buf.append("(");
				buf.append(fv[i].getField().getName());
				buf
						.append((fv[i].getSortDirection() == Constants.ORDER_ASCENDING) ? opA1
								: opA2);

				// OpA
				buf.append(" ? ");

				// generate the "f(i-1) OpB(i-1) f(i-1)* OR f(i-2) OpB(i-2)
				// f(i-2)* OR ... OR f1 OpB f1*"
				if (i > 0) {
					for (int j = i - 1; j >= 0; j--) {
						buf.append(disj);
						buf.append(fv[j].getField().getName());
						buf
								.append((fv[j].getSortDirection() == Constants.ORDER_ASCENDING) ? opB1
										: opB2);

						// OpB
						buf.append(" ? ");
					}
				}

				buf.append(" ) ");

				if (i < (fv.length - 1)) {
					buf.append(conj);

					// link the R's together (conjunction)
				}
			}
		}

		return buf.toString();
	}

	/**
	 * situation: we have an array of fieldvalues (== fields + actual value )
	 * with search information and we want to build a where - clause [that
	 * should restrict the resultset in matching to the search fields].
	 * 
	 * <pre>
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *            convention:    index 0-n =&gt; AND
	 *                           index (n+1)-m =&gt; OR
	 *            examples
	 *                       (A = 'meier' AND X = 'joseph') AND (AGE = '10')
	 *                       (A = 'meier' ) AND (X = 'joseph' OR AGE = '10')
	 *                       (X = 'joseph' OR AGE = '10')
	 *                       (A = 'meier' AND X = 'joseph')
	 *            for comparing to code:
	 *              1     2        3      2          4    5   6      2      7
	 *              (   A = 'smith' AND   X LIKE 'jose%' )    AND    (  AGE = '10'   )
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 * </pre>
	 * 
	 * @param fv
	 *            Description of the Parameter
	 * 
	 * @return _part_ of a WHERE-clause
	 * 
	 * @todo hkk checkme: implementation is different to comment! comment says
	 *       that all or fields will be anded to all and fields (second
	 *       example!) implementation do an or instead????
	 */
	private String getWhereEqualsSearchClause(FieldValue[] fv) {
		StringBuffer buf = new StringBuffer();

		if ((fv != null) && (fv.length > 0)) {
			int mode;
			int oldMode = -1;

			for (int i = 0; i < fv.length; i++) {
				mode = fv[i].getSearchMode();

				if (oldMode != mode) {
					oldMode = mode;
					buf.append("(");

					// 1, 6
				}

				// 2, i.e "A = 'smith'" or "X LIKE 'jose%'"
				buf.append(getSQLExpression(fv[i]));

				if ((i < (fv.length - 1))
						&& (fv[i + 1].getSearchMode() == mode)) {
					buf.append((mode == Constants.SEARCHMODE_AND) ? "AND "
							: "OR ");

					// 3
				} else {
					// if(i==fv.length-1 || fv[i+1].getSearchMode()!=mode) {
					buf.append(")");

					// 4, 7
					if (i != (fv.length - 1)) {
						buf.append(" OR ");

						// 5 #checkme
					}
				}
			}
		}

		return buf.toString();
	}

	/**
	 * The orderBy clause usually defaults to ASCending order. A user may add,
	 * if we/she wishes the keyword ASC (ascending) or DESC (descending) to
	 * specify a particular direction. <br>
	 * Code in this method parses the orderBy clause and finds an occurence of
	 * either ASC or DESC. Suppose your field name is "DESCRIPTION" !<br>
	 * This name contains "DESC" therefore causing unexpected behaviour. This
	 * bug fix consists of fine-tunning the parsing function to take into
	 * consideration the sequence of parameters: 1-Field 2-Command
	 * 
	 * @param order
	 *            order string
	 * 
	 * @return a vector of Field objects
	 */
	private Vector createOrderFVFromAttribute(String order) {
		Vector result = new Vector();

		if (order != null) {
			StringTokenizer st = new StringTokenizer(order, ",");

			while (st.hasMoreTokens()) {
				// Remove leading and trailing white space characters.
				String token = st.nextToken().trim();
				logCat.info("token = " + token);

				int sortDirection = Constants.ORDER_ASCENDING;

				// we propose the default
				// Separate field from command
				int index = token.indexOf(" ");

				// Blank space used between field and command
				if (index != -1) // Do we have a command, if not assume ASC
				// order
				{
					String command = token.substring(index).toUpperCase();
					int pos = command.indexOf("ASC");

					if (pos == -1) // ASC not found, try descending
					{
						pos = command.indexOf("DESC");

						if (index != -1) {
							sortDirection = Constants.ORDER_DESCENDING;

							// ... we set DESC.
						}
					}
				}

				String fieldName;

				if (index == -1) {
					fieldName = token.trim();
				} else {
					fieldName = token.substring(0, index).trim();
				}

				Field f = this.getFieldByName(fieldName);

				if (f != null) {
					FieldValue fv = FieldValue.createFieldValueForSorting(f,
							sortDirection);
					logCat.info("Field '" + fieldName + "' is ordered in mode:"
							+ sortDirection);
					result.addElement(fv);
				}
			}
		}

		return result;
	}

	/**
	 * DOCUMENT ME!
	 * 
	 * @param request
	 * @param paramStub
	 * @param sortFields
	 * 
	 * @return
	 */
	private Vector createOrderFVFromRequest(HttpServletRequest request,
			String paramStub, Vector sortFields) {
		Vector result = new Vector();
		int fieldIndex = paramStub.length() + 1;

		// "sort_1" -> fieldindex= 8 (length of paramStub "order_1" is 7)
		for (int i = 0; i < sortFields.size(); i++) {
			String dataParam = (String) sortFields.elementAt(i);
			int fieldId = Integer.parseInt(dataParam.substring(fieldIndex));
			String sortState = ParseUtil.getParameter(request, dataParam);
			logCat.info("### dataparam=" + dataParam);
			logCat.info("### fieldId=" + fieldId);
			logCat.info("### sortState=" + sortState);

			if (sortState.equalsIgnoreCase("asc")
					|| sortState.equalsIgnoreCase("desc")) {
				int sortDirection = sortState.equalsIgnoreCase("asc") ? Constants.ORDER_ASCENDING
						: Constants.ORDER_DESCENDING;
				FieldValue fv = FieldValue.createFieldValueForSorting(
						getField(fieldId), sortDirection);
				result.addElement(fv);
			}
		}

		return result;
	}

	// ------------------------------ dealing with Postion and key Strings
	// ---------------------------------

	/**
	 * Creates a token string with the format:
	 * 
	 * <pre>
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *               field.id : field.length : field.value
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 * </pre>
	 * 
	 * @param field
	 *            the field object
	 * @param fieldValue
	 *            the field value
	 * 
	 * @return the token string
	 */
	private String createToken(Field field, String fieldValue) {
		StringBuffer buf = new StringBuffer();

		buf.append(field.getId());
		buf.append(":");

		if (!Util.isNull(fieldValue)) {
			buf.append(fieldValue.length());
			buf.append(":");
			buf.append(fieldValue);
		} else {
			buf.append(0);
			buf.append(":");
		}

		return buf.toString();
	}

	/**
	 * Fill the input PreparedStatement object
	 * 
	 * @param cur
	 *            the FieldValue object
	 * @param ps
	 *            the PreparedStatement object
	 * @param curCol
	 *            the current PreparedStatement column; points to a
	 *            PreparedStatement xxx value
	 * 
	 * @return DOCUMENT ME!
	 * 
	 * @exception SQLException
	 *                if any error occurs
	 */
	private int fillPreparedStatement(FieldValue cur, PreparedStatement ps,
			int curCol) throws SQLException {
		logCat.info("setting col " + curCol + " with name "
				+ cur.getField().getName() + " to value " + cur.getFieldValue()
				+ " of type " + cur.getField().getType() + " operator "
				+ cur.getOperator());

		Field curField = cur.getField();
		Object curValue = cur.getFieldValueAsObject();

		// 20020703-HKK: Extending search algorithm with WEAK_START, WEAK_END,
		// WEAK_START_END
		// results in like '%search', 'search%', '%search%'
		if (FieldTypes.isCHAR(curField.getType())) {
			String valueStr = cur.getFieldValue();

			switch (cur.getSearchAlgorithm()) {
			case Constants.SEARCH_ALGO_WEAK_START:
				valueStr = '%' + valueStr;

				break;

			case Constants.SEARCH_ALGO_WEAK_END:
				valueStr = valueStr + '%';

				break;

			case Constants.SEARCH_ALGO_WEAK_START_END:
				valueStr = '%' + valueStr + '%';

				break;
			}

			curValue = valueStr;
		}

		switch (cur.getOperator()) {
		case Constants.FILTER_NULL:
			break;

		case Constants.FILTER_NOT_NULL:
			break;

		case Constants.FILTER_EMPTY:
			break;

		case Constants.FILTER_NOT_EMPTY:
			break;

		default:
			JDBCDataHelper.fillWithData(ps, curField.getEscaper(), curCol,
					curValue, curField.getType(), getBlobHandlingStrategy());
			curCol++;
		}

		return curCol;
	}

	/**
	 * This method generated a datastructure holding sorting information from
	 * "orderBy" only the keys are used as order criteria. By default all
	 * ascending (check SQL spec + docu).
	 */
	private void initDefaultOrderFromKeys() {
		defaultOrder = new FieldValue[getKey().size()];

		for (int i = 0; i < this.getKey().size(); i++) {
			Field keyField = (Field) getKey().elementAt(i);
			defaultOrder[i] = FieldValue.createFieldValueForSorting(keyField,
					Constants.ORDER_ASCENDING);
		}

		logCat.info("Table.initDefaultOrderfromKey done.");
	}

	/**
	 * situation: we have built a query (involving the getWhereEqualsClause()
	 * method) and now we want to prepare the statemtent - provide actual values
	 * for the the '?' placeholders.
	 * 
	 * @param fv
	 *            the array of FieldValue objects
	 * @param ps
	 *            the PreparedStatement object
	 * @param curCol
	 *            the current PreparedStatement column; points to a
	 *            PreparedStatement xxx value
	 * 
	 * @return the value of the current column
	 * 
	 * @exception SQLException
	 *                if any error occurs
	 */
	private int populateWhereAfterClause(FieldValue[] fv, PreparedStatement ps,
			int curCol) throws SQLException {
		if ((fv != null) && (fv.length > 0)) {
			// populate the Ri's
			for (int i = 0; i < fv.length; i++) {
				// populate a "fi OpA(i) fi*"
				curCol = fillPreparedStatement(fv[i], ps, curCol);

				// populate the "f(i-1) OpB(i-1) f(i-1)* OR f(i-2) OpB(i-2)
				// f(i-2)* OR ... OR f1 OpB f1*"
				if (i > 0) {
					for (int j = i - 1; j >= 0; j--) {
						curCol = fillPreparedStatement(fv[j], ps, curCol);
					}
				}
			}
		}

		return curCol;
	}

	protected static DbFormsConfig getConfig() {
		DbFormsConfig config = null;
		try {
			config = DbFormsConfigRegistry.instance().lookup();
		} catch (Exception e) {
			logCat.error("no config object", e);
		}
		return config;
	}

}
