/*
 * $Header$
 * $Revision$
 * $Date$
 *
 * DbForms - a Rapid Application Development Framework
 * Copyright (C) 2001 Joachim Peer <joepeer@excite.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */

package org.dbforms.config;
import java.util.Locale;
import java.util.Vector;
import java.util.Iterator;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import javax.servlet.http.HttpServletRequest;
import org.apache.log4j.Category;
import org.dbforms.util.ParseUtil;
import org.dbforms.util.SqlUtil;
import org.dbforms.util.Util;
import org.dbforms.util.MessageResourcesInternal;



/**
 * This class represents a table tag in dbforms-config.xml (dbforms config xml file).
 * <br>
 * It also defines a lot of methods for preparing and actually performing
 * operations (queries) on the table
 *
 * @author Joe Peer
 */
public class Table
{
   /** log4j category */
   private Category logCat = Category.getInstance(this.getClass().getName());

   /** id of this table (generated by DbFormsConfig when parsing dbforms-config.xml) */
   private int id;

   /** the Field-Objects this table constists of */
   private Vector fields;

   /** subset of "fields", containting those keys which represent keys */
   private Vector key;

   /** the name of the Table */
   private String name;

   /** structure for quick acessing of fields "by name" */
   private Hashtable fieldNameHash;
   private Vector    foreignKeys;

   /** access foreign key by name */
   private Hashtable foreignKeyNameHash;

   /**
    * subset of "fields", containting those keys which represent DISKBLOBs
    * (wondering about that term? -> see docu)
    */
   private Vector diskblobs;

   /**
    * instance variables concerned with the ORDERING/SORTING characterstics
    * of that table (ordering and sorting is used synonym here)
    */
   private String orderBy;

   /** the order-by clause, as specified in dbforms-config.xml (optional!) */
   private FieldValue[] defaultOrder;

   /**
    * access control list for this object (if null, then its open to all users
    * for all operations). Defined in dbforms-config.xml
    */
   private GrantedPrivileges grantedPrivileges = null;

   /** application hookups */
   private Vector interceptors;

   /** config object */
   protected DbFormsConfig config;

   /** Holds value of property defaultVisibleFields. */
   private String defaultVisibleFields;

   /** reference to a TableEvents object */
   private TableEvents tableEvents = null;

   /** reference to the DataAccess Class */
   private String dataAccessClass = null;

   /** some sort of alias to set in dbforms-config, not used yet */
   private String alias = null;

   /**
    * Creates a new Table object.
    */
   public Table()
   {
      fields             = new Vector();
      key                = new Vector();
      fieldNameHash      = new Hashtable();
      diskblobs          = new Vector();
      interceptors       = new Vector();
      foreignKeys        = new Vector();
      foreignKeyNameHash = new Hashtable();
   }

   /**
    * returns object containing info about rights mapped to user-roles.
    * (context: this table object!)
    *
    * @return the GrantedPrivileges object
    */
   public GrantedPrivileges getGrantedPrivileges()
   {
      return grantedPrivileges;
   }


   /**
    *  Checks if there exists a granted-privileges object and if so it
    *  queries if access/operation is possible
    *
    * @param request  the request object
    * @param privileg the privilege value
    * @return true if the user has got privileges over this table, false otherwise
    */
   public boolean hasUserPrivileg(HttpServletRequest request, int privileg)
   {
      return (grantedPrivileges == null)
                ? true : grantedPrivileges.hasUserPrivileg(request, privileg);
   }


   /**
    *  Set GrantedPrivileges, if defined in dbforms-config-xml
    *  (this method gets called from XML-digester).
    *
    * @param grantedPrivileges the grantedPrivileges object
    */
   public void setGrantedPrivileges(GrantedPrivileges grantedPrivileges)
   {
      this.grantedPrivileges = grantedPrivileges;
   }


   /**
    *  Add an interceptor to this table.
    *
    * @param interceptor the interceptor to add
    */
   public void addInterceptor(Interceptor interceptor)
   {
      interceptors.addElement(interceptor);
   }


   /**
    *  Get all the interceptor objects related to this table.
    *
    * @return a vector containing all the interceptor objects
    *         related to this table.
    */
   public Vector getInterceptors()
   {
      return interceptors;
   }


   /**
    * Check if this table has got interceptors.
    *
    * @return true if the table contains interceptors, false otherwise
    */
   public boolean hasInterceptors()
   {
      return (interceptors != null) && (interceptors.size() > 0);
   }


   /**
    * Adds a Field-Object to this table and puts it into othere datastructure
    * for further references (this method gets called from DbFormsConfig)
    *
    * @param field the Field object to add
    */
   public void addField(Field field) throws Exception
   {
      if(field.getType() == 0)
         throw new Exception("no type!");
      field.setId(fields.size());
      fields.addElement(field);

      // if the field is (part of) the key
      if (field.getKey())
      {
         logCat.info("wow - field " + getName() + "." + field.getName()
                     + " is a key");
         key.addElement(field);
      }
      else
      {
         logCat.info("field " + getName() + "." + field.getName()
                     + " is NO key");
      }


      // for quicker lookup by name:
      fieldNameHash.put(field.getName(), field);

      // for quicker check for diskblobs
      if (field.getType() == FieldTypes.DISKBLOB)
      {
         diskblobs.addElement(field);
      }
   }


   /**
    *  Adds a ForeignKey-Object to this table
    *  and puts it into othere datastructure for further references
    *  (this method gets called from DbFormsConfig)
    *
    * @param fk the foreign key object
    */
   public void addForeignKey(ForeignKey fk)
   {
      fk.setId(foreignKeys.size());


      // add to vector containing all foreign keys:
      foreignKeys.addElement(fk);


      // for quicker lookup by name:
      foreignKeyNameHash.put(fk.getName(), fk);
   }


   /**
    *  Returns the Field-Objet with specified id.
    *
    * @param fieldId The id of the field to be returned
    * @return the Field object having the input id
    */
   public Field getField(int fieldId)
   {
      return (Field) fields.elementAt(fieldId);
   }


   /**
    *  Sets the ID of this table
    *  (this method gets called from DbFormsConfig).
    *
    * @param id  the id value to set
    */
   public void setId(int id)
   {
      this.id = id;
   }


   /**
    *  Returns ID of this table.
    *
    * @return the id value
    */
   public int getId()
   {
      return id;
   }


   /**
    *  Sets the name of the table
    *  (this method gets called from XML-digester)
    *
    * @param name the name of the table
    */
   public void setName(String name)
   {
      this.name = name;
   }


   /**
    *  Returns name of the table
    *
    * @return the name of this table
    */
   public String getName()
   {
      return name;
   }


   /**
    * @return String
    */
   public String getDataAccessClass()
   {
      return dataAccessClass;
   }


   /**
    * Sets the dataAccessClass.
    * @param dataAccessClass The dataAccessClass to set
    */
   public void setDataAccessClass(String dataAccessClass)
   {
      this.dataAccessClass = dataAccessClass;
   }


   /**
    * @return String
    */
   public String getAlias()
   {
      return alias;
   }


   /**
    * @param alias the alias to set
    */
   public void setAlias(String alias)
   {
      this.alias = alias;
   }


   /**
    *  Set configuration for table
    *
    * @param config the DbFormsConfig object
    */
   public void setConfig(DbFormsConfig config)
   {
      this.config = config;
   }


   /**
    *  Returns readOnly mode for table needed in DbFormTag.
    *  <br>
    *  In case of table returns always false.
    *  Should be overloaded from e.g. view!.
    *
    * @return true if the table is in readOnly mode; false otherwise
    */
   public boolean isReadOnly()
   {
      return false;
   }


   /**
    *  Returns the vector of fields this table constists of
    *
    * @return the vector of fields this table constists of
    */
   public Vector getFields()
   {
      return fields;
   }


   /**
    *  Returns the field-objects as specified by name (or null if no field with
    *  the specified name exists in this table).
    *
    * @param name The name of the field
    * @return Filed object having the input name
    */
   public Field getFieldByName(String name)
   {
      return (Field) fieldNameHash.get(name);
   }


   /**
    *  Returns the key of this table (consisting of Field-Objects
    *  representing key-fields).
    *
    * @return the key of this table (consisting of Field-Objects
    *         representing key-fields)
    */
   public Vector getKey()
   {
      return key;
   }


   /**
    *  Determinates if this table contains a diskblob field.
    *  (this method is used by DeleteEvent which needs to delete
    *  files referenced by a diskblob field).
    *
    * @return true if this table contains a diskblob field, false otherwise
    */
   public boolean containsDiskblob()
   {
      return diskblobs.size() > 0;
   }


   /**
    *  Returns a Vector of Field-Objects representing fields of type "DISKBLOB"
    *
    * @return a Vector of Field-Objects representing fields of type "DISKBLOB"
    */
   public Vector getDiskblobs()
   {
      return diskblobs;
   }


   /**
    *  This method generates a datastructure holding sorting information
    *  from "orderBy" clause in XML-config.
    */
   public void initDefaultOrder()
   {
      // if developer specified no orderBy in XML, then we set the KEYs as DEFAULT ORDER
      if (orderBy == null)
      {
         initDefaultOrderFromKeys();
      }
      else
      {
         // build the datastructure, containing Fields, and infos about sort
         defaultOrder = createOrderFieldValues(orderBy, null, true);
      }

      logCat.info("Table.initDefaultOrder done.");
   }


   /**
    *  This method generated a datastructure holding sorting information from
    *  "orderBy" only the keys are used as order criteria.
    *  By default all ascending (check SQL spec + docu).
    */
   private void initDefaultOrderFromKeys()
   {
      defaultOrder = new FieldValue[getKey().size()];

      for (int i = 0; i < this.getKey().size(); i++)
      {
         Field keyField = (Field) getKey().elementAt(i);
         defaultOrder[i] = FieldValue.createFieldValueForSorting(keyField, 
                                                                 Constants.ORDER_ASCENDING);
      }

      logCat.info("Table.initDefaultOrderfromKey done.");
   }


   /**
    *  Sets a default-orderBy clause from xml config
    *  (this method gets called from XML-digester).
    *
    * @param orderBy the orderBy clause
    */
   public void setOrderBy(String orderBy)
   {
      this.orderBy = orderBy;
   }


   /**
    * Return default-orderBy clause from xml config or null if not specified.
    *
    * @return the default-orderBy clause from xml config
    *         or null if not specified.
    */
   public String getOrderBy()
   {
      return orderBy;
   }


   /**
    *  Return the datastructure containing info about the default
    *  sorting behavior of this table.
    *
    * @return the datastructure containing info about the default
    *         sorting behavior of this table.
    */
   public FieldValue[] getDefaultOrder()
   {
      return defaultOrder;
   }


   /**
    *  Get the table events object related to this table.
    *  <br>
    *  If it is null (because user didn't specify custom events),
    *  set a new TableEvents object and return its reference.
    *
    * @return the table events object related to this table
    */
   public TableEvents getTableEvents()
   {
      if (tableEvents == null)
      {
         tableEvents = new TableEvents();
      }

      return tableEvents;
   }


   /**
    *  Set the table events object related to this table.
    *
    * @param tableEvents  the table events object related to this table
    */
   public void setTableEvents(TableEvents tableEvents)
   {
      this.tableEvents = tableEvents;
      tableEvents.setTable(this);
   }


   //------------------------------ SQL methods ---------------------------------

   /**
    *  Get the SQL select statement.
    *
    * @return the SQL select statement
    */
   public String getSelectStatement()
   {
      StringBuffer queryBuf = new StringBuffer();
      queryBuf.append("SELECT ");
      queryBuf.append(getQuerySelect(fields));
      queryBuf.append(" FROM ");
      queryBuf.append(getQueryFrom());
      logCat.info(queryBuf.toString());

      return queryBuf.toString();
   }


   /**
    *  Generates part of a field list for a  SQL SELECT clause selecting
    *  the DISKBLOB fields from a table (used by DeleteEvent to maintain
    *  data consistence).
    *
    * @return a part of a field list for a SQL SELECT clause selecting
    *         the DISKBLOB fields from a table
    */
   public String getDisblobSelectStatement()
   {
      StringBuffer buf = new StringBuffer();
      buf.append("SELECT ");

      int cnt = diskblobs.size();

      for (int i = 0; i < cnt; i++)
      {
         Field diskblobField = (Field) diskblobs.elementAt(i);


         // get the name of the encoded key field
         buf.append(diskblobField.getName());

         if (i < (cnt - 1))
         {
            buf.append(", ");
         }
      }

      buf.append(" FROM ");
      buf.append(getQueryFrom());

      return buf.toString();
   }


   /**
    *  Returns SQL delete statement, used by deleteEvent.
    *
    * @return the SQL delete statement
    */
   public String getDeleteStatement()
   {
      // now we start building the DELETE statement
      StringBuffer queryBuf = new StringBuffer();
      queryBuf.append("DELETE FROM ");
      queryBuf.append(getQueryToChange());
      queryBuf.append(" WHERE ");
      queryBuf.append(getWhereClauseForPS());
      logCat.info(queryBuf.toString());

      return queryBuf.toString();
   }


   /**
    *  Returns SQL update statement, used by updateEvent.
    *
    * @param fieldValues the Hashtable object containing the field values
    * @return the SQL update statement
    */
   public String getUpdateStatement(FieldValues fieldValues)
   {
      StringBuffer queryBuf = new StringBuffer();
      queryBuf.append("UPDATE ");
      queryBuf.append(getQueryToChange());
      queryBuf.append(" SET ");

      // list the names of fields and the place holder for their new values
      // important: these are the fields which are sent through the current request;
      // this list may be only a subset of the field list, 
      //  it is not necessarily the complete field list of a table!
      Iterator enum        = fieldValues.keys();
      boolean  kommaNeeded = false;

      while (enum.hasNext())
      {
         String fieldName = (String) enum.next();

         if (kommaNeeded)
         {
            queryBuf.append(", ");
         }
         else
         {
            kommaNeeded = true;
         }

         queryBuf.append(fieldName);
         queryBuf.append("= ?");
      }

      queryBuf.append(" WHERE ");
      queryBuf.append(getWhereClauseForPS());
      logCat.info(queryBuf.toString());

      return queryBuf.toString();
   }


   /**
    *  Returns SQL insert statement, used by insertEvent.
    *
    * @param fieldValues the Hashtable containing the field values
    * @return the SQL insert statement
    */
   public String getInsertStatement(FieldValues fieldValues)
   {
      StringBuffer queryBuf = new StringBuffer();
      queryBuf.append("INSERT INTO ");
      queryBuf.append(getQueryToChange());
      queryBuf.append(" (");

      // list the names of fields we'll include into the insert operation
      Iterator enum = fieldValues.keys();

      while (enum.hasNext())
      {
         String fieldName = (String) enum.next();
         queryBuf.append(fieldName);

         if (enum.hasNext())
         {
            queryBuf.append(",");
         }
      }


      // list the place-holders for the fields to include
      queryBuf.append(") VALUES (");

      for (int i = 0; i < fieldValues.size(); i++)
      {
         if (i != 0)
         {
            queryBuf.append(",");
         }

         queryBuf.append("?");
      }

      queryBuf.append(")");
      logCat.info(queryBuf.toString());

      return queryBuf.toString();
   }


   /**
    *  Returns the select part of a query.
    *
    * @param fieldsToSelect the vector containing the Field objects
    *                       used to build the elect part of the query
    * @return               the select part of a query
    */
   protected String getQuerySelect(Vector fieldsToSelect)
   {
      if (fieldsToSelect != null)
      {
         StringBuffer buf                = new StringBuffer();
         int          fieldsToSelectSize = fieldsToSelect.size();

         // #checkme: do i need this when using Hotspot ?
         // we scroll through vector directly (no enumeration!)
         // to maintain correct order of elements
         for (int i = 0; i < fieldsToSelectSize; i++)
         {
            Field f = (Field) fieldsToSelect.elementAt(i);
            buf.append(f.getName());
            buf.append(", ");
         }

         buf.deleteCharAt(buf.length() - 2);

         return buf.toString();
      }

      return "*";
   }


   /**
    *  Returns the FROM part of a query.
    *
    * @return the FROM part of a query
    */
   protected String getQueryFrom()
   {
      return name;
   }


   /**
    *  Returns the FROM part of a insert/delete/update query.
    *
    * @return the FROM part of a insert/delete/update query
    */
   protected String getQueryToChange()
   {
      return getQueryFrom();
   }


   /**
    *  Returns the WHERE part of a query.
    *
    * @param fvEqual     FieldValue array used to restrict a set in a subform where
    *                    all "childFields" in the  resultset match their respective
    *                    "parentFields" in main form
    * @param fvOrder     FieldValue array used to build a cumulation of rules for ordering
    *                    (sorting) and restricting fields
    * @param compareMode compare mode value for generating the order clause
    * @return the WHERE part of a query
    */
   protected String getQueryWhere(FieldValue[] fvEqual, FieldValue[] fvOrder, 
                                  int compareMode)
   {
      boolean      firstTermExists = false;
      StringBuffer buf = new StringBuffer();

      // build the first term;
      if (!FieldValue.isNull(fvEqual))
      {
         // check if the fieldvalues contain _search_ information
         buf.append(" ( ");

         if (fvEqual[0].getSearchMode() == Constants.SEARCHMODE_NONE)
         {
            buf.append(getWhereClause(fvEqual));
         }
         else
         {
            buf.append(getWhereEqualsSearchClause(fvEqual));
         }

         buf.append(" ) ");
         firstTermExists = true;
      }

      // build the second term;
      // this SHOULD be the WHERE clause which restricts
      // the query to rows coming AFTER the row containing the actual data.
      if (!FieldValue.isNull(fvOrder))
      {
         if (compareMode != Constants.COMPARE_NONE)
         {
            buf.append(firstTermExists ? " AND ( " : "");
            buf.append(getWhereAfterClause(fvOrder, compareMode));
            buf.append(firstTermExists ? " ) " : "");
         }
      }

      return buf.toString();
   }


   /**
    *  Returns the part of the orderby-clause represented by this
    *  FieldValue object.
    *  <br>
    *  (ASC will be not printed because it is defined DEFAULT in SQL
    *  if there are RDBMS which do not tolerate this please let me know;
    *  then i'll change it).
    *
    * @param fvOrder FieldValue array used to build a cumulation of rules for
    *                ordering (sorting) and restricting fields
    * @return the part of the orderby-clause represented by this
    *         FieldValue object
    */
   protected String getQueryOrderBy(FieldValue[] fvOrder)
   {
      StringBuffer buf = new StringBuffer();

      if (fvOrder != null)
      {
         for (int i = 0; i < fvOrder.length; i++)
         {
            buf.append(fvOrder[i].getField().getName());

            if (fvOrder[i].getSortDirection() == Constants.ORDER_DESCENDING)
            {
               buf.append(" DESC");
            }

            if (i < (fvOrder.length - 1))
            {
               buf.append(",");
            }
         }
      }

      return buf.toString();
   }


   /**
    *  Prepares the Querystring for the select statement
    *
    * Order of parts:
    *  1. sqlFilter                                               (fild in getDoSelectResultSet!)
    *  2. where condition generated from having / ordering fields (fild in populateWhereEqualsClause)
    *
    *  Retrieving the parameters in getDoSelectResultSet() must match this
    *  order!
    *
    * @param fieldsToSelect  vector of fields to be selected
    * @param fvEqual         fieldValues representing values we are looking for
    * @param fvOrder         fieldValues representing needs for order clauses
    * @param sqlFilter       sql condition to and with the where clause
    * @param compareMode     compare mode value for generating the order clause
    * @return the query string
    */
   public String getSelectQuery(Vector fieldsToSelect, FieldValue[] fvEqual, 
                                FieldValue[] fvOrder, String sqlFilter, 
                                int compareMode)
   {
      StringBuffer buf = new StringBuffer();

      buf.append("SELECT ");
      buf.append(getQuerySelect(fieldsToSelect));
      buf.append(" FROM ");
      buf.append(getQueryFrom());

      String s = getQueryWhere(fvEqual, fvOrder, compareMode);

      if (!Util.isNull(s) || !Util.isNull(sqlFilter))
      {
         buf.append(" WHERE ");
      }

      // where condition from DbFormTag's sqlFilter attribute
      if (!Util.isNull(sqlFilter))
      {
         buf.append(" ( ");
         buf.append(sqlFilter);
         buf.append(" ) ");
      }

      // where condition generated from searching / ordering
      if (!Util.isNull(s))
      {
         if (!Util.isNull(sqlFilter))
         {
            buf.append(" AND ");
         }

         buf.append(" ( ");
         buf.append(s);
         buf.append(" ) ");
      }

      s = getQueryOrderBy(fvOrder);

      if (s.length() > 0)
      {
         buf.append(" ORDER BY ");
         buf.append(s);
      }

      logCat.info("::getSelectQuery - [" + buf.toString() + "]");

      return buf.toString();
   }


   /**
    *  Prepares the Querystring for the free form select statement
    *
    * @param fieldsToSelect  vector of fields to be selected
    * @param whereClause     free-form whereClause to be appended to query
    * @param tableList       the list of tables involved into the query
    * @return the query string
    */
   public String getFreeFormSelectQuery(Vector fieldsToSelect, 
                                        String whereClause, String tableList)
   {
      StringBuffer buf = new StringBuffer();
      buf.append("SELECT ");
      buf.append(getQuerySelect(fieldsToSelect));
      buf.append(" FROM ");

      if (Util.isNull(tableList))
      {
         buf.append(getQueryFrom());
      }
      else
      {
         buf.append(tableList);
      }

      buf.append(" ");
      buf.append(whereClause);
      logCat.info("::getFreeFormSelectQuery -- [" + buf.toString() + "]");

      return buf.toString();
   }


   /**
    *  Get the SQL ResultSet from the query builded using the input data.
    *
    *
    * Order of parts:
    *  1. sqlFilter
    *  2. where condition generated from searching
    *  3. where condition generated from ordering
    *
    *  Generating the query in getSelectQuery()  must match this
    *  order!
    *
    * @param fvEqual     FieldValue array used to restrict a set in a subform where
    *                    all "childFields" in the  resultset match their respective
    *                    "parentFields" in main form
    * @param fvOrder     FieldValue array used to build a cumulation of rules for ordering
    *                    (sorting) and restricting fields
    * @param compareMode the value of the compare mode
    * @param ps          the PreparedStatement object
    * @return a ResultSet object
    * @throws SQLException if any error occurs
    */
   public ResultSet getDoSelectResultSet(FieldValue[] fvEqual, 
                                         FieldValue[] fvOrder, 
                                         FieldValue[] sqlFilterParams, 
                                         int compareMode, PreparedStatement ps)
                                  throws SQLException
   {
      // the index of the first NOT POPULATED placeholder;
      int curCol = 1;

      logCat.debug("###getDoSelectResultSet pos1");

      if (!FieldValue.isNull(sqlFilterParams))
      {
         curCol = populateWhereEqualsClause(sqlFilterParams, ps, curCol);
      }

      logCat.debug("###getDoSelectResultSet pos2");

      if (!FieldValue.isNull(fvEqual))
      {
         curCol = populateWhereEqualsClause(fvEqual, ps, curCol);
      }

      logCat.debug("###getDoSelectResultSet pos3");

      if ((compareMode != Constants.COMPARE_NONE) && (fvOrder != null)
                && (fvOrder.length > 0))
      {
         populateWhereAfterClause(fvOrder, ps, curCol);
      }

      ResultSet result = null;

      try
      {
         result = ps.executeQuery();
      }
      catch (SQLException sqle)
      {
         SqlUtil.logSqlException(sqle);
         throw sqle;
      }

      return result;
   }


   //------------------------------ Old ResultSetVector stuff ---------------------------------

   /**
    *  Do a constrained select.
    *
    * @param fieldsToSelect vector containing all the fields to select
    * @param fvEqual FieldValue array used to restrict a set in a subform where
    *                all "childFields" in the  resultset match their respective
    *                "parentFields" in main form
    * @param fvOrder FieldValue array used to build a cumulation of rules for ordering
    *                (sorting) and restricting fields
    * @param sqlFilter sql condition to add to where clause
    * @param compareMode the value of the compare mode
    * @param maxRows the max number of rows to manage
    * @param con the connection object
    * @return a ResultSetVector object
    * @throws SQLException if any error occurs
    */
   public ResultSetVector doConstrainedSelect(Vector fieldsToSelect, 
                                              FieldValue[] fvEqual, 
                                              FieldValue[] fvOrder, 
                                              String sqlFilter, 
                                              FieldValue[] sqlFilterParams, 
                                              int compareMode, int maxRows, 
                                              Connection con)
                                       throws SQLException
   {
      String            query = getSelectQuery(fieldsToSelect, fvEqual, fvOrder, 
                                               sqlFilter, compareMode);
      PreparedStatement ps = con.prepareStatement(query);
      ps.setMaxRows(maxRows); // important when quering huge tables

      ResultSet rs = getDoSelectResultSet(fvEqual, fvOrder, sqlFilterParams, 
                                          compareMode, ps);
      ResultSetVector result = new ResultSetVector(fieldsToSelect, rs);
      ps.close();
      logCat.info("::doConstrainedSelect - rsv size = " + result.size());

      return result;
   }


   /**
    *  perform free-form select query
    *
    *  @param fieldsToSelect vector of fields to be selected
    *  @param whereClause    free-form whereClause to be appended to query
    *  @param maxRows        how many rows should be stored in the resultSet (zero means unlimited)
    *  @param tableList      the list of tables involved into the query
    *  @param con            the active db connection to use
    *  @return the ResultSetVector object
    *  @throws SQLException if any error occurs
    */
   public ResultSetVector doFreeFormSelect(Vector fieldsToSelect, 
                                           String whereClause, String tableList, 
                                           int maxRows, Connection con)
                                    throws SQLException
   {
      Statement       stmt   = con.createStatement();
      ResultSet       rs;
      ResultSetVector result;
      String          query = getFreeFormSelectQuery(fieldsToSelect, 
                                                     whereClause, tableList);
      stmt.setMaxRows(maxRows); // important when quering huge tables

      try
      {
         rs = stmt.executeQuery(query);
      }
      catch (SQLException sqle)
      {
         SqlUtil.logSqlException(sqle);
         throw new SQLException(sqle.getMessage());
      }

      result = new ResultSetVector(fieldsToSelect, rs);


      // 20021115-HKK: resultset is closed in ResultSetVector()
      // rs.close();
      stmt.close();
      logCat.info("rsv size=" + result.size());

      return result;
   }


   //------------------------------ dealing with Postion and key Strings ---------------------------------

   /**
    *  Creates a token string with the format:
    *  <pre>
    *    field.id : field.length : field.value
    *  </pre>
    *
    * @param field  the field object
    * @param fieldValue the field value
    * @return the token string
    */
   private String createToken(Field field, String fieldValue)
   {
      StringBuffer buf = new StringBuffer();

      buf.append(field.getId());
      buf.append(":");

      if (!Util.isNull(fieldValue))
      {
         buf.append(fieldValue.length());
         buf.append(":");
         buf.append(fieldValue);
      }
      else
      {
         buf.append(0);
         buf.append(":");
      }

      return buf.toString();
   }


   /**
    *  Does basically the same as getPositionString but only for key-fields.
    *  <br>
    *  #checkme: could be merged with getPositionString<br>
    *  #fixme: replace seperator-based tokenization by better algoithm!
    *
    * @param rsv the ResultSetVector object
    * @return the position string for key fields
    */
   public String getKeyPositionString(ResultSetVector rsv)
   {
      if (ResultSetVector.isNull(rsv))
      {
         return null;
      }

      String[] currentRow = rsv.getCurrentRow();

      if (currentRow == null)
      {
         return null;
      }

      return getKeyPositionString(currentRow);
   }


   /**
    *  Does basically the same as getPositionString but only for key-fields.
    *
    * @param currentRow the currentRow as String[]
    * @return the position string
    */
   public String getKeyPositionString(String[] currentRow)
   {
      StringBuffer buf = new StringBuffer();

      if (currentRow != null)
      {
         for (int i = 0; i < getKey().size(); i++)
         {
            Field f = (Field) getKey().elementAt(i);

            if (i > 0)
            {
               buf.append("-"); // control byte
            }

            buf.append(createToken(f, currentRow[f.getId()]));
         }
      }

      return buf.toString();
   }


   /**
    * Get key position from the input hash table
    *
    * @param  fvHT has field as key and FieldValue as value!
    *
    * @return the key position string
    */
   public String getKeyPositionString(FieldValues fvHT)
   {
      if (fvHT != null)
      {
         StringBuffer buf = new StringBuffer();
         int          cnt = 0;

         for (int i = 0; i < getKey().size(); i++)
         {
            Field      f  = (Field) getKey().elementAt(i);
            FieldValue fv = fvHT.get(f.getName());

            if (fv != null)
            {
               String value = fv.getFieldValue();

               if (value == null)
               {
                  throw new IllegalArgumentException("wrong fields provided");
               }

               if (cnt > 0)
               {
                  buf.append("-"); // control byte
               }

               buf.append(createToken(f, value));
               cnt++;
            }
         }

         return buf.toString();
      }
      else
      {
         return null;
      }
   }


   /**
    *  Builds a "position- string" representing the values of the current row in the given
    *  ResultSetVector.
    *  <br>
    *  Not all field-values get explicitl listed in this string. only fields important
    *  for navigation and sorting are listed.
    *  <br>
    *  Position strings are used as request parameters allowing the framework to keep track
    *  of the position the user comes from or goes to.
    *  <br>
    *  Look into com.itp.tablib.DbFormTag for better understanding
    *
    * changed 0-04-2001 by joe
    * #note: enhanced algorithm since version 0.9!
    *
    * @param rsv the ResultSetVector object
    * @return the position string
    */
   public String getPositionString(ResultSetVector rsv)
   {
      if (ResultSetVector.isNull(rsv))
      {
         return null;
      }

      String[] currentRow = rsv.getCurrentRow();

      if (currentRow == null)
      {
         return null;
      }

      return getPositionString(currentRow);
   }


   /**
    *  Builds a "position- string" representing the values of the current row in the given
    *  ResultSetVector.
    *  <br>
    *  Not all field-values get explicitly listed in this string. only fields important
    *  for navigation and sorting are listed.
    *  <br>
    *  Position strings are used as request parameters allowing the framework to keep track
    *  of the position the user comes from or goes to.
    *  <br>
    *
    * @param currentRow the currentRow as String[]
    * @return the position string
    */
   public String getPositionString(String[] currentRow)
   {
      StringBuffer buf = new StringBuffer();
      int          cnt = 0;

      for (int i = 0; i < getFields().size(); i++)
      {
         Field f = (Field) getFields().elementAt(i);

         if (f.getKey() || f.isSortable())
         {
            if (cnt > 0)
            {
               buf.append("-"); // control byte
            }

            buf.append(createToken(f, currentRow[f.getId()]));
            cnt++;
         }
      }

      return buf.toString();
   }


   /**
    *  Used for instance by goto with prefix
    *
    * @param ht the Hashtable object containing the field names
    *           used to build the position string
    *         ht has fieldName as key and valueStr as value!
    * @return the position string
    */
   public String getPositionString(Hashtable ht)
   {
      StringBuffer buf  = new StringBuffer();
      int          cnt  = 0;
      Iterator     enum = ht.keySet().iterator();

      while (enum.hasNext())
      {
         String fieldName = (String) enum.next();
         Field  aField = getFieldByName(fieldName);

         if ((aField != null) && (aField.getKey() || aField.isSortable()))
         {
            String fieldValue = (String) ht.get(fieldName);

            if (cnt > 0)
            {
               buf.append('-'); // control byte
            }

            buf.append(createToken(aField, fieldValue));
            cnt++;
         }
         else
         {
            logCat.error("provided goto field " + fieldName + " not found!");
         }
      }

      return buf.toString();
   }


   /**
    * Get key position from the input hash table
    *
    * @param  fvHT has field as key and FieldValue as value!
    *
    * @return the key position string
    */
   public String getPositionString(FieldValues fvHT)
   {
      if (fvHT != null)
      {
         StringBuffer buf  = new StringBuffer();
         int          cnt  = 0;
         Iterator     enum = fvHT.keys();

         while (enum.hasNext())
         {
            String     fieldName = (String) enum.next();
            FieldValue fv = fvHT.get(fieldName);
            Field      f  = fv.getField();

            if (f.getKey() || f.isSortable())
            {
               String value = fv.getFieldValue();

               if (value == null)
               {
                  throw new IllegalArgumentException("wrong fields provided");
               }

               if (cnt > 0)
               {
                  buf.append("-"); // control byte
               }

               buf.append(createToken(f, value));
               cnt++;
            }
         }

         return buf.toString();
      }
      else
      {
         return null;
      }
   }


   /**
    *  This method parses a position string and build a data structure
    *  representing the values of the fields decoded from the position.
    *  <br>
    *  #fixme: replace seperator-based tokenization by better algoithm!
    *
    * @param position the position string
    * @return the HashTable containing the FieldValues of the fields decoded,
    *          key of the HashTable is the fieldName!
    */
   public FieldValues getFieldValues(String position)
   {
      // 20020705-HKK: Position maybe string with length = 0!!!!
      if ((position == null) || (position.length() == 0))
      {
         return null;
      }

      // trailing blanks are significant for CHAR database fields
      //	position = position.trim();
      // 20021128-HKK: catch errors!
      // 2003-03-29 HKK: Change from Hashtable to FieldValueTable
      FieldValues result = new FieldValues();

      try
      {
         int     startIndex  = 0;
         boolean endOfString = false;

         // looping through the string
         while (!endOfString)
         {
            int firstColon  = position.indexOf(':', startIndex);
            int secondColon = position.indexOf(':', firstColon + 1);

            if ((firstColon == -1) && (secondColon == -1))
            {
               return null;
            }

            String fieldIdStr = position.substring(startIndex, firstColon);
            int    fieldId = Integer.parseInt(fieldIdStr);

            String valueLengthStr = position.substring(firstColon + 1, 
                                                       secondColon);
            int    valueLength = Integer.parseInt(valueLengthStr);

            int    controlIndex = secondColon + 1 + valueLength;

            // make already be trimmed ... avoid substring exception
            String valueStr = (controlIndex < position.length())
                                 ? position.substring(secondColon + 1, 
                                                      controlIndex)
                                 : position.substring(secondColon + 1);

            Field  f  = getField(fieldId);
            FieldValue fv = new FieldValue(f, valueStr);
            result.put(fv);

            if (controlIndex == position.length())
            {
               endOfString = true;
            }
            else if (controlIndex > position.length())
            {
               logCat.warn("Controlbyte wrong but continuing execution");
               endOfString = true;
            }
            else
            {
               char controlByte = position.charAt(controlIndex);

               if (controlByte != '-')
               {
                  logCat.error("Controlbyte wrong, abandon execution");
                  throw new IllegalArgumentException();
               }

               startIndex = controlIndex + 1;

               if (position.length() == startIndex)
               {
                  endOfString = true;
               }
            }
         }
      }
      catch (Exception e)
      {
         logCat.error("::getFieldValuesFromPositionAsHt - exception:", e);
         result = null;
      }

      return result;
   }


   /**
    *  in version 0.9 this method moved from FieldValue.fillWithValues to Table.fillWithValues
    *
    * @param orderConstraint  FieldValue array used to build a cumulation of rules
    *                         for ordering (sorting) and restricting fields
    * @param aPosition        resultset position
    */
   public void fillWithValues(FieldValue[] orderConstraint, String aPosition)
   {
      // 2003-03-29 HKK: Change from Hashtable to FieldValueTable 
      FieldValues ht = getFieldValues(aPosition);

      // 20021104-HKK: Error handling if aPosition is not given!
      if (ht != null)
      {
         logCat.info("*** parsing through: " + aPosition);

         // then we copy some of those values into the orderConstraint
         for (int i = 0; i < orderConstraint.length; i++)
         {
            Field f = orderConstraint[i].getField();

            if (f != null)
            {
               FieldValue aFieldValue = ht.get(f.getName());

               if (aFieldValue != null)
               {
                  orderConstraint[i].setFieldValue(aFieldValue.getFieldValue());
               }
               else
               {
                  logCat.warn("position entry has null value:" + f.getName());
               }
            }
         }
      }
   }


   // ----------------- some convenience methods ---------------------------------------------

   /**
    *  Generates a part of the SQL where clause needed to select a distinguished row form the table.
    *  This is done by querying for KEY VALUES !
    *
    * @return  a part of the SQL where clause needed to select a distinguished
    *          row form the table
    */
   public String getWhereClauseForPS()
   {
      StringBuffer buf = new StringBuffer();
      int          cnt = this.getKey().size();

      for (int i = 0; i < cnt; i++)
      {
         Field keyField = (Field) this.getKey().elementAt(i);


         // get the name of the encoded key field
         buf.append(keyField.getName());
         buf.append(" = ?");

         if (i < (cnt - 1))
         {
            buf.append(" AND ");
         }
      }

      return buf.toString();
   }


   /**
    *  POPULATES a part of the SQL where clause needed to select a distinguished
    *  row form the table using values endcoded in a string.
    *  <br>
    *  #fixme: replace seperator-based tokenization by better algoithm!
    *
    * @param  keyValuesStr the position string
    * @param  ps           the PreparedStatement object
    * @param  startColumn  PreparedStatement start column
    * @throws SQLException if any error occurs
    */
   public void populateWhereClauseWithKeyFields(String keyValuesStr, 
                                                PreparedStatement ps, 
                                                int startColumn)
                                         throws SQLException
   {
      int col = startColumn;

      // then we list the values of the key-fields, so that the WHERE clause
      // matches the right dataset
      // 2003-03-29 HKK: Change from Hashtable to FieldValueTable 
      FieldValues keyValuesHt = getFieldValues(keyValuesStr);
      int         keyLength = this.getKey().size();

      for (int i = 0; i < keyLength; i++)
      {
         Field      curField    = (Field) this.getKey().elementAt(i);
         FieldValue aFieldValue = keyValuesHt.get(curField.getName());
         Object     value       = aFieldValue.getFieldValueAsObject();
         JDBCDataHelper.fillPreparedStatement(ps, col, value, 
                                              curField.getType());
         col++;
      }
   }


   /**
    *  The orderBy clause usually defaults to ASCending order.
    *  A user may add, if we/she wishes the keyword ASC (ascending)
    *  or DESC (descending) to specify a particular direction.
    *  <br>
    *  Code in this method parses the orderBy clause and finds an occurence
    *  of either ASC or DESC.  Suppose your field name is "DESCRIPTION" !
    *  <br>
    *  This name contains "DESC" therefore causing unexpected behaviour.
    *  This bug fix consists of fine-tunning the parsing function to take into
    *  consideration the sequence of parameters: 1-Field 2-Command
    *
    * @param order order string
    * @return a vector of Field objects
    *
    * @author Grunikiewicz.philip@hydro.qc.ca
    * @date   2001-08-09
    */
   private Vector createOrderFVFromAttribute(String order)
   {
      Vector result = new Vector();

      if (order != null)
      {
         StringTokenizer st = new StringTokenizer(order, ",");

         while (st.hasMoreTokens())
         {
            //Remove leading and trailing white space characters.
            String token = st.nextToken().trim();
            logCat.info("token = " + token);

            boolean sortDirection = Constants.ORDER_ASCENDING;

            // we propose the default
            //Separate field from command
            int index = token.indexOf(" ");

            // Blank space used between field and command
            if (index != -1) // Do we have a command, if not assume ASC order
            {
               String command = token.substring(index).toUpperCase();
               int    pos = command.indexOf("ASC");

               if (pos == -1) // ASC not found, try descending
               {
                  pos = command.indexOf("DESC");

                  if (index != -1)
                  {
                     sortDirection = Constants.ORDER_DESCENDING;

                     // ... we set DESC.
                  }
               }
            }

            String fieldName;

            if (index == -1)
            {
               fieldName = token.trim();
            }
            else
            {
               fieldName = token.substring(0, index).trim();
            }

            Field f = this.getFieldByName(fieldName);

            if (f != null)
            {
               FieldValue fv = FieldValue.createFieldValueForSorting(f, 
                                                                     sortDirection);
               logCat.info("Field '" + fieldName + "' is ordered in mode:"
                           + sortDirection);
               result.addElement(fv);
            }
         }
      }

      return result;
   }


   /**
    *
    * @param request
    * @param paramStub
    * @param sortFields
    * @return
    */
   private Vector createOrderFVFromRequest(HttpServletRequest request, 
                                           String paramStub, Vector sortFields)
   {
      Vector result     = new Vector();
      int    fieldIndex = paramStub.length() + 1;

      // "sort_1" -> fieldindex= 8 (length of paramStub "order_1" is 7)
      for (int i = 0; i < sortFields.size(); i++)
      {
         String dataParam = (String) sortFields.elementAt(i);
         int    fieldId   = Integer.parseInt(dataParam.substring(fieldIndex));
         String sortState = ParseUtil.getParameter(request, dataParam);
         logCat.info("### dataparam=" + dataParam);
         logCat.info("### fieldId=" + fieldId);
         logCat.info("### sortState=" + sortState);

         if (sortState.equalsIgnoreCase("asc")
                   || sortState.equalsIgnoreCase("desc"))
         {
            boolean sortDirection = sortState.equalsIgnoreCase("asc")
                                       ? Constants.ORDER_ASCENDING
                                       : Constants.ORDER_DESCENDING;
            FieldValue fv = FieldValue.createFieldValueForSorting(getField(fieldId), 
                                                                  sortDirection);
            result.addElement(fv);
         }
      }

      return result;
   }


   /**
    *  Column ["ASC" | "DESC"] {"," Column ["ASC" | "DESC"] }
    *  (if neither ASC nor DESC follow "Col", then ASC is choosen as default).
    *  <br>
    *  this method assures, that ALL KEY FIELDs are part of the order criteria,
    *  in any case (independly from the order-Str). if necessary it appends them.
    *  WHY: to ensure correct scrollig (not getting STUCK if the search criteria
    *  are not "sharp" enough).
    *  <br>
    * #fixme - better explaination
    * #fixme - determinate illegal input and throw IllegalArgumentException
    *
    * @param order       a String from JSP provided by the user in SQL-Style
    * @param request     the request object
    * @param includeKeys true to include key fields, false otherwise
    * @return            ???
    */
   public FieldValue[] createOrderFieldValues(String order, 
                                              HttpServletRequest request, 
                                              boolean includeKeys)
   {
      Vector result = null;

      if (request != null)
      {
         String paramStub  = "sort_" + this.getId();
         Vector sortFields = ParseUtil.getParametersStartingWith(request, 
                                                                 paramStub);

         if (sortFields.size() > 0)
         {
            result = createOrderFVFromRequest(request, paramStub, sortFields);
         }
      }

      // 20020703-HKK: use the default order if result.size == 0, not only if result == null
      //               This happens if  all parameters with sort_  are set to none
      if (((result == null) || result.isEmpty()))
      {
         // 20021104-HKK: use default order from table if form has no order!
         if (order == null)
         {
            order = getOrderBy();
         }

         result = createOrderFVFromAttribute(order);

         logCat.debug("@@@ 1");

         for (int i = 0; i < result.size(); i++)
         {
            FieldValue fieldVal = (FieldValue) result.elementAt(i);
            logCat.debug("fieldValue " + fieldVal.toString());
         }
      }

      if ((result == null) && !includeKeys)
      {
         return null; // then we've got definitely no over
      }

      // scroll through keys and append to order criteria, if not already included
      for (int i = 0; i < this.getKey().size(); i++)
      {
         Field   keyField = (Field) getKey().elementAt(i);
         boolean found = false;
         int     j     = 0;

         while (!found && (j < result.size()))
         {
            FieldValue fv = (FieldValue) result.elementAt(j);

            if (fv.getField() == keyField)
            {
               found = true;
            }

            j++;
         }

         if (!found)
         {
            result.addElement(FieldValue.createFieldValueForSorting(keyField, 
                                                                    Constants.ORDER_ASCENDING));
         }
      }

      FieldValue[] resultArray = new FieldValue[result.size()];
      result.copyInto(resultArray);
      logCat.debug("@@@ 2");

      for (int i = 0; i < resultArray.length; i++)
      {
         logCat.debug("fieldValue " + resultArray[i].toString());
      }

      return resultArray;
   }


   //------------------------------ utility / helper methods ---------------------------------

   /**
    *  This metod is useful for logging / debugging purposes only.
    *
    * @return a string containing the Table name and field values
    */
   public String traverse()
   {
      StringBuffer buf = new StringBuffer();
      buf.append("\nname=");
      buf.append(name);
      buf.append(" ");

      for (int i = 0; i < getFields().size(); i++)
      {
         Field f = (Field) getFields().elementAt(i);
         buf.append("\nfield: ");
         buf.append(f.toString());
      }

      return buf.toString();
   }


   /**
    *  Process the interceptor objects related to this table.
    *
    * @param action           DOCUMENT ME!
    * @param request          the request object
    * @param associativeArray DOCUMENT ME!
    * @param config           the config object
    * @param con              the JDBC connection object
    *
    * @throws SQLException if any error occurs
    * @throws MultipleValidationException if any validation error occurs
    */
   public int processInterceptors(int action, HttpServletRequest request, 
                                  FieldValues fieldValues, DbFormsConfig config, 
                                  Connection con) throws SQLException
   {
      String s;

      try
      {
         int interceptorsCnt = interceptors.size();

         for (int i = 0; i < interceptorsCnt; i++)
         {
            Interceptor        interceptor      = (Interceptor) interceptors.elementAt(i);
            Class              interceptorClass = Class.forName(
                                                           interceptor.getClassName());
            DbEventInterceptor dbi = (DbEventInterceptor) interceptorClass.newInstance();

            // (Sunil_Mishra@adp.com) - The return type to check for the
            // IGNORE_OPERATION
            int operation;

            if (action == DbEventInterceptor.PRE_INSERT)
            {
               operation = dbi.preInsert(request, this, fieldValues, config, 
                                         con);

               switch (operation)
               {
                  case DbEventInterceptor.DENY_OPERATION:
                     s = MessageResourcesInternal.getMessage(
                                  "dbforms.events.insert.nogrant", 
                                  request.getLocale(), 
                                  new String[] 
                     {
                        getName()
                     });
                     throw new SQLException(s);

                  case DbEventInterceptor.IGNORE_OPERATION:
                     return operation;
               }
            }
            else if (action == DbEventInterceptor.POST_INSERT)
            {
               dbi.postInsert(request, config, con);
            }
            else if (action == DbEventInterceptor.PRE_UPDATE)
            {
               operation = dbi.preUpdate(request, this, fieldValues, config, 
                                         con);

               switch (operation)
               {
                  case DbEventInterceptor.DENY_OPERATION:
                     s = MessageResourcesInternal.getMessage(
                                  "dbforms.events.update.nogrant", 
                                  request.getLocale(), 
                                  new String[] 
                     {
                        getName()
                     });
                     throw new SQLException(s);

                  case DbEventInterceptor.IGNORE_OPERATION:
                     return operation;
               }
            }
            else if (action == DbEventInterceptor.POST_UPDATE)
            {
               dbi.postUpdate(request, config, con);
            }
            else if (action == DbEventInterceptor.PRE_DELETE)
            {
               operation = dbi.preDelete(request, this, fieldValues, config, 
                                         con);

               switch (operation)
               {
                  case DbEventInterceptor.DENY_OPERATION:
                     s = MessageResourcesInternal.getMessage(
                                  "dbforms.events.delete.nogrant", 
                                  request.getLocale(), 
                                  new String[] 
                     {
                        getName()
                     });
                     throw new SQLException(s);

                  case DbEventInterceptor.IGNORE_OPERATION:
                     return operation;
               }
            }
            else if (action == DbEventInterceptor.POST_DELETE)
            {
               dbi.postDelete(request, config, con);
            }
            else if (action == DbEventInterceptor.PRE_SELECT)
            {
               operation = dbi.preSelect(request, config, con);

               switch (operation)
               {
                  case DbEventInterceptor.DENY_OPERATION:
                     s = MessageResourcesInternal.getMessage(
                                  "dbforms.events.view.nogrant", 
                                  request.getLocale(), 
                                  new String[] 
                     {
                        getName()
                     });
                     throw new SQLException(s);

                  case DbEventInterceptor.IGNORE_OPERATION:
                     return operation;
               }
            }
            else if (action == DbEventInterceptor.POST_SELECT)
            {
               dbi.postSelect(request, config, con);
            }
         }
      }
      catch (ClassNotFoundException cnfe)
      {
         logCat.warn(" ClassNotFoundException : " + cnfe.getMessage());
         throw new SQLException(cnfe.getMessage());
      }
      catch (InstantiationException ie)
      {
         logCat.warn(" InstantiationException : " + ie.getMessage());
         throw new SQLException(ie.getMessage());
      }
      catch (IllegalAccessException iae)
      {
         logCat.warn(" IllegalAccessException : " + iae.getMessage());
         throw new SQLException(iae.getMessage());
      }
      catch (SQLException sqle)
      {
         throw sqle;
      }
	  catch (MultipleValidationException ve)
	  {
		  throw new SQLException(ve.getMessage());
	  }
      catch (ValidationException ve)
      {
         throw new SQLException(ve.getMessage());
      }

      return DbEventInterceptor.GRANT_OPERATION;
   }


   /**
    * We have the field ID - we need the field name
    *
    * @param fieldID fieldID to get field name from
    * @return the field name
    */
   public String getFieldName(int fieldID)
   {
      Field f = (Field) getFields().elementAt(fieldID);

      return (f.getName());
   }


   /**
    * returns the hash table. Moved from dbFormTag to table, so that you can overload it!
    *
    * @param core starting tag for the fields
    * @return hash table of names
    *                in PHP slang we would call that an "associative array" :=)
    *
    */
   public Hashtable getNamesHashtable(String core)
   {
      Hashtable result = new Hashtable();
      Iterator  enum = getFields().iterator();

      while (enum.hasNext())
      {
         Field        f         = (Field) enum.next();
         String       fieldName = f.getName();
         int          fieldId   = f.getId();
         StringBuffer sb        = new StringBuffer(core);
         sb.append("_");
         sb.append(getId());
         sb.append("_");
         sb.append(fieldId);
         result.put(fieldName, sb.toString());
      }

      return result;
   }


   /**
    * Getter for property defaultVisibleFields.
    *
    * @return Value of property defaultVisibleFields.
    */
   public String getDefaultVisibleFields()
   {
      return this.defaultVisibleFields;
   }


   /**
    * Setter for property defaultVisibleFields.
    *
    * @param defaultVisibleFields New value of property defaultVisibleFields.
    */
   public void setDefaultVisibleFields(String defaultVisibleFields)
   {
      this.defaultVisibleFields = defaultVisibleFields;
   }


   /**
    * maps chield fields to parent fields
    *
    * @param parentTable the parent table
    * @param parentFieldString field names in parent table
    * @param childFieldString  field names in child table
    * @param aPosition         position to map as position string
    *
    * @return FieldValues with result
    */
   public FieldValues mapChildFieldValues(Table parentTable, 
                                          String parentFieldString, 
                                          String childFieldString, 
                                          String aPosition)
   {
      // 1 to n fields may be mapped
      Vector childFieldNames  = ParseUtil.splitString(childFieldString, ",;~");
      Vector parentFieldNames = ParseUtil.splitString(parentFieldString, ",;~");

      // do some basic checks
      // deeper checks like Datatyp-compatibility,etc not done yet
      int len = childFieldNames.size();

      if ((len == 0) || (len != parentFieldNames.size()))
      {
         return null;
      }

      // 2003-03-29 HKK: Change from Hashtable to FieldValueTable 
      FieldValues ht = parentTable.getFieldValues(aPosition);

      if (ht == null)
      {
         return null;
      }

      FieldValues childFieldValues = new FieldValues();

      for (int i = 0; i < len; i++)
      {
         String     parentFieldName = (String) parentFieldNames.elementAt(i);
         Field      parentField    = parentTable.getFieldByName(parentFieldName);
         String     childFieldName = (String) childFieldNames.elementAt(i);
         Field      childField     = this.getFieldByName(childFieldName);
         FieldValue aFieldValue    = ht.get(parentField.getName());

         if (aFieldValue == null)
         {
            throw new IllegalArgumentException("ERROR: Make sure that field "
                                               + parentField.getName()
                                               + " is a KEY of the table "
                                               + parentTable.getName()
                                               + "! Otherwise you can not use it as PARENT/CHILD LINK argument!");
         }

         String currentParentFieldValue = aFieldValue.getFieldValue();
         childFieldValues.put(
                  new FieldValue(childField, currentParentFieldValue));
      }

      return childFieldValues;
   }


   /**
    * Build the WHERE clause string using the input field values.
    *
    * @param fv the array of FieldValue objects
    *
    * @return the WHERE clause string
    *
    * protected so that it can be tested
    */
   protected String getWhereClause(FieldValue[] fv)
   {
      StringBuffer buf = new StringBuffer();

      if ((fv != null) && (fv.length > 0))
      {
         // SM 2003-08-08: added brackets for each and-ed condition
         buf.append(" ( ");

         for (int i = 0; i < fv.length; i++)
         {
            // depending on the value of isLogicalOR in FieldValue,
            // prefix the filter definition with either OR or AND
            // (Skip first entry!)
            if (i != 0)
            {
               if (fv[i].getLogicalOR())
               {
                  buf.append(" OR ");
               }
               else
               {
                  buf.append(" ) AND ( ");
               }
            }

            buf.append(getSQLExpression(fv[i]));
         }

         buf.append(" ) ");
      }

      return buf.toString();
   }


   /**
    * situation: we have an array of fieldvalues (== fields + actual value )
    * with search information and we want to build a where - clause [that
    * should restrict the resultset in matching to the search fields].
    * <pre>
    * convention:    index 0-n => AND
    *                index (n+1)-m => OR
    * examples
    *            (A = 'meier' AND X = 'joseph') AND (AGE = '10')
    *            (A = 'meier' ) AND (X = 'joseph' OR AGE = '10')
    *            (X = 'joseph' OR AGE = '10')
    *            (A = 'meier' AND X = 'joseph')
    * for comparing to code:
    *   1     2        3      2          4    5   6      2      7
    *   (   A = 'smith' AND   X LIKE 'jose%' )    AND    (  AGE = '10'   )
    * </pre>
    *
    * @param fv Description of the Parameter
    *
    * @return _part_ of a WHERE-clause
    *
    * @todo hkk checkme: implementation is different to comment!
    *                    comment says that all or fields will be anded to all and fields (second example!)
    *                    implementation do an or instead????
    *
    */
   private String getWhereEqualsSearchClause(FieldValue[] fv)
   {
      StringBuffer buf = new StringBuffer();

      if ((fv != null) && (fv.length > 0))
      {
         int mode;
         int oldMode = -1;

         for (int i = 0; i < fv.length; i++)
         {
            mode = fv[i].getSearchMode();

            if (oldMode != mode)
            {
               oldMode = mode;
               buf.append("(");

               // 1, 6
            }


            // 2, i.e "A = 'smith'" or "X LIKE 'jose%'"
            buf.append(getSQLExpression(fv[i]));

            if ((i < (fv.length - 1)) && (fv[i + 1].getSearchMode() == mode))
            {
               buf.append((mode == Constants.SEARCHMODE_AND) ? "AND " : "OR ");

               // 3
            }
            else
            {
               //if(i==fv.length-1 || fv[i+1].getSearchMode()!=mode) {
               buf.append(")");

               // 4, 7
               if (i != (fv.length - 1))
               {
                  buf.append(" OR ");

                  // 5 #checkme
               }
            }
         }
      }

      return buf.toString();
   }


   /**
    * situation: we have built a query (involving the getWhereEqualsClause()
    * method) and now we want to prepare the statemtent - provide actual
    * values for the the '?' placeholders
    *
    * @param fv the array of FieldValue objects
    * @param ps the PreparedStatement object
    * @param curCol the current PreparedStatement column; points to a
    *        PreparedStatement xxx value
    *
    * @return the current column value
    *
    * @exception SQLException if any error occurs
    */
   protected int populateWhereEqualsClause(FieldValue[] fv, 
                                           PreparedStatement ps, int curCol)
                                    throws SQLException
   {
      if ((fv != null) && (fv.length > 0))
      {
         for (int i = 0; i < fv.length; i++)
         {
            curCol = fillPreparedStatement(fv[i], ps, curCol);
         }
      }

      return curCol;
   }


   /**
    * situation: we have an array of fieldvalues which represents actual values
    * of order-determinating-fields. we want to build a part of the WHERE
    * clause which restricts the query to rows coming AFTER the row containing
    * the actual data. <br>
    * shortly described the following rule is applied:
    * <pre>
    * +--------------------------------------------------------------------------------------------------+
    * |  RULE = R1 AND R2 AND ... AND Rn                                                                 |
    * |  Ri = fi OpA(i) fi* OR  f(i-1) OpB(i-1) f(i-1)* OR f(i-2) OpB(i-2) f(i-2)* OR ... OR f1 OpB f1*  |
    * +--------------------------------------------------------------------------------------------------+
    * For background info email joepeer@wap-force.net
    * </pre>
    * IMPORTANT NOTE: the indizes of the fv-array indicate implicitly the
    * order-priority of the fields. <br>
    * example: if we have ORDER BY id,name,age -> then fv[0] should contain
    * field id, fv[1] should contain field name, fv[2] should contain field
    * age
    *
    * @param fv the array of FieldValue objects
    * @param compareMode the comparison mode
    *
    * @return _part_ of a WHERE-clause
    */
   private String getWhereAfterClause(FieldValue[] fv, int compareMode)
   {
      String conj;
      String disj;
      String opA1;
      String opA2;
      String opB1;
      String opB2;

      // COMPARE_INCLUSIVE
      if (compareMode == Constants.COMPARE_INCLUSIVE)
      {
         opA1 = ">=";
         opA2 = "<=";
         opB1 = ">";
         opB2 = "<";
         conj = " AND ";
         disj = " OR ";
      }
      else
      {
         opA1 = ">";
         opA2 = "<";
         opB1 = ">=";
         opB2 = "<=";
         conj = " OR ";
         disj = " AND ";
      }

      StringBuffer buf = new StringBuffer();

      if ((fv != null) && (fv.length > 0))
      {
         // generate the Ri's
         for (int i = 0; i < fv.length; i++)
         {
            // generate a "fi OpA(i) fi*"
            buf.append("(");
            buf.append(fv[i].getField().getName());
            buf.append((fv[i].getSortDirection() == Constants.ORDER_ASCENDING)
                          ? opA1 : opA2);


            // OpA
            buf.append(" ? ");

            // generate the "f(i-1) OpB(i-1) f(i-1)* OR f(i-2) OpB(i-2) f(i-2)* OR ... OR f1 OpB f1*"
            if (i > 0)
            {
               for (int j = i - 1; j >= 0; j--)
               {
                  buf.append(disj);
                  buf.append(fv[j].getField().getName());
                  buf.append((fv[j].getSortDirection() == Constants.ORDER_ASCENDING)
                                ? opB1 : opB2);


                  // OpB
                  buf.append(" ? ");
               }
            }

            buf.append(" ) ");

            if (i < (fv.length - 1))
            {
               buf.append(conj);

               // link the R's together (conjunction)
            }
         }
      }

      return buf.toString();
   }


   /**
    * situation: we have built a query (involving the getWhereEqualsClause()
    * method) and now we want to prepare the statemtent - provide actual
    * values for the the '?' placeholders.
    *
    * @param fv the array of FieldValue objects
    * @param ps the PreparedStatement object
    * @param curCol the current PreparedStatement column; points to a
    *        PreparedStatement xxx value
    *
    * @return the value of the current column
    *
    * @exception SQLException if any error occurs
    */
   private int populateWhereAfterClause(FieldValue[] fv, PreparedStatement ps, 
                                        int curCol) throws SQLException
   {
      if ((fv != null) && (fv.length > 0))
      {
         // populate the Ri's
         for (int i = 0; i < fv.length; i++)
         {
            // populate a "fi OpA(i) fi*"
            curCol = fillPreparedStatement(fv[i], ps, curCol);

            // populate the "f(i-1) OpB(i-1) f(i-1)* OR f(i-2) OpB(i-2) f(i-2)* OR ... OR f1 OpB f1*"
            if (i > 0)
            {
               for (int j = i - 1; j >= 0; j--)
               {
                  curCol = fillPreparedStatement(fv[j], ps, curCol);
               }
            }
         }
      }

      return curCol;
   }


   /**
    * returns an SQLExpression based on the given FieldValue
    * @param fv the FieldValue
    * @return string holding the SQL Expression
    */
   private String getSQLExpression(FieldValue fv)
   {
      StringBuffer buf = new StringBuffer();

      // 20021104-HKK: Check for expression.
      Field  f         = fv.getField();
      String fieldName = Util.isNull(f.getExpression())
                            ? f.getName() : f.getExpression();
      buf.append(fieldName);

      // Check what type of operator is required
      switch (fv.getOperator())
      {
         case Constants.FILTER_EQUAL:
            buf.append(" = ");
            buf.append(" ? ");

            break;

         case Constants.FILTER_NOT_EQUAL:
            buf.append(" <> ");
            buf.append(" ? ");

            break;

         case Constants.FILTER_GREATER_THEN:
            buf.append(" > ");
            buf.append(" ? ");

            break;

         case Constants.FILTER_SMALLER_THEN:
            buf.append(" < ");
            buf.append(" ? ");

            break;

         case Constants.FILTER_GREATER_THEN_EQUAL:
            buf.append(" >= ");
            buf.append(" ? ");

            break;

         case Constants.FILTER_SMALLER_THEN_EQUAL:
            buf.append(" <= ");
            buf.append(" ? ");

            break;

         case Constants.FILTER_LIKE:

            if (f.getType() == FieldTypes.CHAR)
            {
               buf.append(" LIKE ");
            }
            else
            {
               buf.append(" = ");
            }

            buf.append(" ? ");

            break;

         case Constants.FILTER_NULL:
            buf.append(" IS NULL ");

            break;

         case Constants.FILTER_NOT_NULL:
            buf.append(" IS NOT NULL ");

            break;

         case Constants.FILTER_EMPTY:

            if (f.getType() == FieldTypes.CHAR)
            {
               buf.append(" = '' ");
               buf.append(" OR ");
            }

            buf.append(fieldName);
            buf.append(" IS NULL ");

            break;

         case Constants.FILTER_NOT_EMPTY:

            if (f.getType() == FieldTypes.CHAR)
            {
               buf.append(" <> '' ");
               buf.append(" OR ");
            }

            buf.append(fieldName);
            buf.append(" IS NOT NULL ");

            break;
      }

      return buf.toString();
   }


   /**
    * Fill the input PreparedStatement object
    *
    * @param cur the FieldValue object
    * @param ps  the PreparedStatement object
    * @param curCol the current PreparedStatement column; points to a
    *        PreparedStatement xxx value
    *
    * @return DOCUMENT ME!
    *
    * @exception SQLException if any error occurs
    */
   private int fillPreparedStatement(FieldValue cur, PreparedStatement ps, 
                                     int curCol) throws SQLException
   {
      logCat.info("setting col " + curCol + " with name "
                  + cur.getField().getName() + " to value "
                  + cur.getFieldValue() + " of type "
                  + cur.getField().getType() + " operator " + cur.getOperator());

      Field  curField = cur.getField();
      Object curValue = cur.getFieldValueAsObject();

      // 20020703-HKK: Extending search algorithm with WEAK_START, WEAK_END, WEAK_START_END
      //               results in like '%search', 'search%', '%search%'
      if (curField.getType() == FieldTypes.CHAR)
      {
         String valueStr = cur.getFieldValue();

         switch (cur.getSearchAlgorithm())
         {
            case Constants.SEARCH_ALGO_WEAK_START:
               valueStr = '%' + valueStr;

               break;

            case Constants.SEARCH_ALGO_WEAK_END:
               valueStr = valueStr + '%';

               break;

            case Constants.SEARCH_ALGO_WEAK_START_END:
               valueStr = '%' + valueStr + '%';

               break;
         }

         curValue = valueStr;
      }

      switch (cur.getOperator())
      {
         case Constants.FILTER_NULL:
            break;

         case Constants.FILTER_NOT_NULL:
            break;

         case Constants.FILTER_EMPTY:
            break;

         case Constants.FILTER_NOT_EMPTY:
            break;

         default:
            JDBCDataHelper.fillPreparedStatement(ps, curCol, curValue, 
                                                 curField.getType());
            curCol++;
      }

      return curCol;
   }


   /**
    * Initialize the filterFieldValues array.
    * @param table the table object
    * @param filter the filter string
    *
    * @return an initialized FieldValue array
    * @todo    add MORE docs here !!!
    */
   public FieldValue[] getFilterFieldArray(String filter, Locale locale)
   {
      // 1 to n fields may be mapped
      Vector keyValPairs = ParseUtil.splitString(filter, ",;");

      // ~ no longer used as separator!
      int          len = keyValPairs.size();

      FieldValue[] result = new FieldValue[len];

      for (int i = 0; i < len; i++)
      {
         int     operator    = 0;
         boolean isLogicalOR = false;
         int     jump        = 1;
         String  aKeyValPair = (String) keyValPairs.elementAt(i);


         // i.e "id=2"
         logCat.debug("initFilterFieldValues: aKeyValPair = " + aKeyValPair);

         // Following code could be optimized, however I did not want to make too many changes...
         int n;

         // Check for Not Equal
         if ((n = aKeyValPair.indexOf("<>")) != -1)
         {
            // Not Equal found! - Store the operation for use later on
            operator = Constants.FILTER_NOT_EQUAL;
            jump     = 2;
         }
         else if ((n = aKeyValPair.indexOf(">=")) != -1)
         {
            // Check for GreaterThanEqual
            // GreaterThenEqual found! - Store the operation for use later on
            operator = Constants.FILTER_GREATER_THEN_EQUAL;
            jump     = 2;
         }
         else if ((n = aKeyValPair.indexOf('>')) != -1)
         {
            // Check for GreaterThan
            // GreaterThen found! - Store the operation for use later on
            operator = Constants.FILTER_GREATER_THEN;
         }
         else if ((n = aKeyValPair.indexOf("<=")) != -1)
         {
            // Check for SmallerThenEqual
            // SmallerThenEqual found! - Store the operation for use later on
            operator = Constants.FILTER_SMALLER_THEN_EQUAL;
            jump     = 2;
         }
         else if ((n = aKeyValPair.indexOf('<')) != -1)
         {
            // Check for SmallerThen
            // SmallerThen found! - Store the operation for use later on
            operator = Constants.FILTER_SMALLER_THEN;
         }
         else if ((n = aKeyValPair.indexOf('=')) != -1)
         {
            // Check for equal
            // Equal found! - Store the operator for use later on
            operator = Constants.FILTER_EQUAL;
         }
         else if ((n = aKeyValPair.indexOf('~')) != -1)
         {
            // Check for LIKE
            // LIKE found! - Store the operator for use later on
            operator = Constants.FILTER_LIKE;
         }
         else if ((n = aKeyValPair.toUpperCase().indexOf("NOTISNULL")) != -1)
         {
            // Check for not is null
            // LIKE found! - Store the operator for use later on
            jump     = 9;
            operator = Constants.FILTER_NOT_NULL;
         }
         else if ((n = aKeyValPair.toUpperCase().indexOf("ISNULL")) != -1)
         {
            // Check for null
            // LIKE found! - Store the operator for use later on
            jump     = 6;
            operator = Constants.FILTER_NULL;
         }

         //  PG - At this point, I have set my operator and I should have a valid index.
         // Note that the original code did not handle the posibility of not finding an index
         // (value = -1)...
         String fieldName = aKeyValPair.substring(0, n).trim();


         // i.e "id"
         logCat.debug("Filter field=" + fieldName);

         if (fieldName.charAt(0) == '|')
         {
            // This filter must be associated to a logical OR, clean out the indicator...
            fieldName   = fieldName.substring(1);
            isLogicalOR = true;
         }

         Field filterField = getFieldByName(fieldName);

         // Increment by 1 or 2 depending on operator
         String value = aKeyValPair.substring(n + jump).trim();


         // i.e. "2"
         logCat.debug("Filter value=" + value);


         // Create a new instance of FieldValue and set the operator variable
         result[i] = FieldValue.createFieldValueForSearching(filterField, value, 
                                                             locale, operator, 
                                                             Constants.SEARCHMODE_NONE, 
                                                             Constants.SEARCH_ALGO_SHARP, 
                                                             isLogicalOR);
         logCat.debug("and fv is =" + result[i].toString());
      }

      return result;
   }
}