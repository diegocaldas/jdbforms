/*
 * $Header$
 * $Revision$
 * $Date$
 *
 * DbForms - a Rapid Application Development Framework
 * Copyright (C) 2001 Joachim Peer <joepeer@excite.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */

package org.dbforms;

import java.util.*;
import java.sql.*;
import javax.servlet.http.HttpServletRequest;

import org.apache.log4j.Category;

import org.dbforms.util.*;
import org.dbforms.event.*;
import org.dbforms.taglib.DbBaseHandlerTag;




/**
 * This class represents a table tag in dbforms-config.xml (dbforms config xml file).
 * <br>
 * It also defines a lot of methods for preparing and actually performing
 * operations (queries) on the table
 *
 * @author Joe Peer <joepeer@excite.com>
 */
public class Table
{
    static Category logCat = Category.getInstance(Table.class.getName());

    /** DOCUMENT ME! */
    public static int GET_EQUAL = 0;

    /** DOCUMENT ME! */
    public static int GET_EQUAL_OR_GREATER = 1;
    private int id;

    // id of this table (generated by DbFormsConfig when parsing dbforms-config.xml)
    private Vector fields; // the Field-Objects this table constists of
    private Vector key;

    // subset of "fields", containting those keys which represent keys
    private String name; // the name of the Table
    private Hashtable fieldNameHash;

    // structure for quick acessing of fields "by name"
    private Vector foreignKeys;
    private Hashtable foreignKeyNameHash; // access foreign key by name
    private Vector diskblobs;

    // subset of "fields", containting those keys which represent DISKBLOBs (wondering about that term? -> see docu)
    // instance variables concerned with the ORDERING/SORTING characterstics of that table (ordering and sorting is used synonym here)
    private String orderBy;

    // the order-by clause, as specified in dbforms-config.xml (optional!)
    private FieldValue[] defaultOrder; // datastructure generated from "orderBy".
    private Vector defaultOrderFields;

    // contains Field-Objects which are referenced in the orderBy-string
    private GrantedPrivileges grantedPrivileges = null;

    // access control list for this object (if null, then its open to all users for all operations). defined in dbforms-config.xml
    private Vector interceptors; // application hookups

    /** DOCUMENT ME! */
    protected DbFormsConfig config;

    /** Holds value of property defaultVisibleFields. */
    private String defaultVisibleFields;


    /** reference to a TableEvents object */
    private TableEvents tableEvents = null;


    /**
     * Creates a new Table object.
     */
    public Table()
    {
        fields = new Vector();
        key = new Vector();
        fieldNameHash = new Hashtable();
        diskblobs = new Vector();
        interceptors = new Vector();
        foreignKeys = new Vector();
        foreignKeyNameHash = new Hashtable();
    }


    /**
     * returns object containing info about rights mapped to user-roles. (context: this table object!)
    */
    public GrantedPrivileges getGrantedPrivileges()
    {
        return grantedPrivileges;
    }


    /**
     * checks if there exists a granted-privileges object and if so it queries if access/operation is possible
     */
    public boolean hasUserPrivileg(HttpServletRequest request, int privileg)
    {
        return (grantedPrivileges == null) ? true : grantedPrivileges.hasUserPrivileg(request, privileg);
    }


    /**
     * set GrantedPrivileges, if defined in dbforms-config-xml
     * (this method gets called from XML-digester)
    */
    public void setGrantedPrivileges(GrantedPrivileges grantedPrivileges)
    {
        this.grantedPrivileges = grantedPrivileges;
    }


    /**
     * DOCUMENT ME!
     *
     * @param interceptor DOCUMENT ME!
     */
    public void addInterceptor(Interceptor interceptor)
    {
        interceptors.addElement(interceptor);
    }


    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Vector getInterceptors()
    {
        return interceptors;
    }


    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public boolean hasInterceptors()
    {
        return (interceptors != null) && (interceptors.size() > 0);
    }


    /**
     * adds a Field-Object to this table
     * and puts it into othere datastructure for further references
     * (this method gets called from DbFormsConfig)
     */
    public void addField(Field field)
    {
        field.setId(fields.size());
        fields.addElement(field);

        if (field.isKey())
        { // if the field is (part of) the key
            logCat.info("wow - field " + field.getName() + " is a key");
            key.addElement(field);
        }
        else
        {
            logCat.info("field " + field.getName() + " is NO key");
        }

        // for quicker lookup by name:
        fieldNameHash.put(field.getName(), field);

        // for quicker check for diskblobs
        if (field.getType() == FieldTypes.DISKBLOB)
        {
            diskblobs.addElement(field);
        }
    }


    /**
     * adds a ForeignKey-Object to this table
     * and puts it into othere datastructure for further references
     * (this method gets called from DbFormsConfig)
     */
    public void addForeignKey(ForeignKey fk)
    {
        fk.setId(foreignKeys.size());

        // add to vector containing all foreign keys:
        foreignKeys.addElement(fk);

        // for quicker lookup by name:
        foreignKeyNameHash.put(fk.getName(), fk);
    }


    /**
     * returns the Field-Objet with specified id
     *
     * @param fieldId The id of the field to be returned
    */
    public Field getField(int fieldId)
    {
        return (Field) fields.elementAt(fieldId);
    }


    /**
     * sets the ID of this table
     * (this method gets called from DbFormsConfig)
    */
    public void setId(int id)
    {
        this.id = id;
    }


    /**
     * returns ID of this table
     */
    public int getId()
    {
        return id;
    }


    /**
     * sets the name of the table
     * (this method gets called from XML-digester)
     */
    public void setName(String name)
    {
        this.name = name;
    }


    /**
     * returns name of the table
    */
    public String getName()
    {
        return name;
    }


    /**
     * set configuration for table
    */
    public void setConfig(DbFormsConfig config)
    {
        this.config = config;
    }


    /**
     * returns readOnly mode for table
     * needed in DbFormTag.
     *
     * In case of table returns always false
     * Should be overloaded from e.g. view!
    */
    public boolean isReadOnly()
    {
        return false;
    }


    /**
     * returns the vector of fields this table constists of
     */
    public Vector getFields()
    {
        return fields;
    }


    /**
     * returns the field-objects as specified by name (or null if no field with
     * the specified name exists in this table)
     * @param name The name of the field
     */
    public Field getFieldByName(String name)
    {
        return (Field) fieldNameHash.get(name);
    }


    /**
     * returns the key of this table (consisting of Field-Objects representing key-fields)
     */
    public Vector getKey()
    {
        return key;
    }


    /**
     * determinates if this table contains a diskblob field.
     * (this method is used by DeleteEvent which needs to delete files referenced
     * by a diskblob field)
     */
    public boolean containsDiskblob()
    {
        return diskblobs.size() > 0;
    }


    /**
     * returns a Vector of Field-Objects representing fields of type "DISKBLOB"
     */
    public Vector getDiskblobs()
    {
        return diskblobs;
    }


    /**
     * this method generates a datastructure holding sorting information
     * from "orderBy".clause in XML-config
     */
    public void initDefaultOrder()
    {
        if (orderBy == null)
        {
            // if developer specified no orderBy in XML, then we set the KEYs as DEFAULT ORDER
            initDefaultOrderFromKeys();

            return;
        }

        // build the datastructure, containing Fields, and infos about sort
        defaultOrder = this.createOrderFieldValues(orderBy, null, true);

        // building a list of the fields contained in the defaultOrder structure
        defaultOrderFields = new Vector();

        for (int i = 0; i < defaultOrder.length; i++)
            defaultOrderFields.addElement(defaultOrder[i].getField());

        logCat.info("Table.initDefaultOrder done.");
    }


    /**
    * this method generated a datastructure holding sorting information from "orderBy"
    * only the keys are used as order criteria. by default all ascending
    * (check SQL spec + docu)
    */
    public void initDefaultOrderFromKeys()
    {
        defaultOrder = new FieldValue[getKey().size()];
        defaultOrderFields = new Vector();

        for (int i = 0; i < this.getKey().size(); i++)
        {
            Field keyField = (Field) getKey().elementAt(i);
            defaultOrder[i] = new FieldValue();
            defaultOrder[i].setField(keyField);
            defaultOrderFields.addElement(keyField);
        }

        logCat.info("Table.initDefaultOrderfromKey done.");
    }


    /**
     * sets a default-orderBy clause from xml config
     * (this method gets called from XML-digester)
     */
    public void setOrderBy(String orderBy)
    {
        this.orderBy = orderBy;
    }


    /**
     * return default-orderBy clause from xml config or null if not specified
     */
    public String getOrderBy()
    {
        return orderBy;
    }


    /**
     * return the datastructure containing info about the default sorting behavior of this table
     */
    public FieldValue[] getDefaultOrder()
    {
        return defaultOrder;
    }


    /**
     * return a list of the fields contained in the defaultOrder structure
     */
    public Vector getDefaultOrderFields()
    {
        return defaultOrderFields;
    }


    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public String getSelectStatement()
    {
        StringBuffer queryBuf = new StringBuffer();
        queryBuf.append("SELECT ");
        queryBuf.append(getQuerySelect(fields));
        queryBuf.append(" FROM ");
        queryBuf.append(getQueryFrom());
        logCat.info(queryBuf.toString());

        return queryBuf.toString();
    }


    /**
     *  Get the table events object related to this table.
     *  <br>
     *  If it is null (because user didn't specify custom events),
     *  set a new TableEvents object and return its reference.
     *
     * @return the table events object related to this table
     */
    public TableEvents getTableEvents()
    {
        if (tableEvents == null)
            tableEvents = new TableEvents();

        return tableEvents;
    }


    /**
     *  Set the table events object related to this table.
     *
     * @rparam tableEvents  the table events object related to this table
     */
    public void setTableEvents(TableEvents tableEvents)
    {
        this.tableEvents = tableEvents;
        tableEvents.setTable(this);
    }


    /**
     * generates part of a field list for a  SQL SELECT clause selecting the DISKBLOB
     * fields from a table
     * (used by DeleteEvent to maintain data consistence)
     */
    public String getDisblobSelectStatement()
    {
        StringBuffer buf = new StringBuffer();
        buf.append("SELECT ");

        int cnt = diskblobs.size();

        for (int i = 0; i < cnt; i++)
        {
            Field diskblobField = (Field) diskblobs.elementAt(i);

            // get the name of the encoded key field
            buf.append(diskblobField.getName());

            if (i < (cnt - 1))
            {
                buf.append(", ");
            }
        }

        buf.append(" FROM ");
        buf.append(getQueryFrom());

        return buf.toString();
    }


    /**
     * returns SQL delete statement, used by deleteEvent
     */
    public String getDeleteStatement()
    {
        // now we start building the DELETE statement
        StringBuffer queryBuf = new StringBuffer();
        queryBuf.append("DELETE FROM ");
        queryBuf.append(getQueryToChange());
        queryBuf.append(" WHERE ");
        queryBuf.append(getWhereClauseForPS());
        logCat.info(queryBuf.toString());

        return queryBuf.toString();
    }


    /**
     * returns SQL update statement, used by updateEvent
     */
    public String getUpdateStatement(Hashtable fieldValues)
    {
        StringBuffer queryBuf = new StringBuffer();
        queryBuf.append("UPDATE ");
        queryBuf.append(getQueryToChange());
        queryBuf.append(" SET ");

        // list the names of fields and the place holder for their new values
        // important: these are the fields which are sent throug the current request;
        // this list may be only a subset of the field list, it is not necessarily the complete field list of a table!
        Vector fields = getFields();
        Enumeration enum = fieldValues.keys();
        boolean kommaNeeded = false;

        while (enum.hasMoreElements())
        {
            Integer iiFieldId = (Integer) enum.nextElement();
            String fieldName = ((Field) getFields().elementAt(iiFieldId.intValue())).getName();

            if (kommaNeeded)
            {
                queryBuf.append(", ");
            }
            else
            {
                kommaNeeded = true;
            }

            queryBuf.append(fieldName);
            queryBuf.append("= ?");
        }

        queryBuf.append(" WHERE ");
        queryBuf.append(getWhereClauseForPS());
        logCat.info(queryBuf.toString());

        return queryBuf.toString();
    }


    /**
     * returns SQL insert statement, used by insertEvent
     */
    public String getInsertStatement(Hashtable fieldValues)
    {
        StringBuffer queryBuf = new StringBuffer();
        queryBuf.append("INSERT INTO ");
        queryBuf.append(getQueryToChange());
        queryBuf.append(" (");

        // list the names of fields we'll include into the insert operation
        Vector fields = getFields();
        Enumeration enum = fieldValues.keys();

        while (enum.hasMoreElements())
        {
            Integer iiFieldId = (Integer) enum.nextElement();
            String fieldName = ((Field) getFields().elementAt(iiFieldId.intValue())).getName();
            queryBuf.append(fieldName);

            if (enum.hasMoreElements())
            {
                queryBuf.append(",");
            }
        }

        // list the place-holders for the fields to include
        queryBuf.append(") VALUES (");

        for (int i = 0; i < fieldValues.size(); i++)
        {
            if (i != 0)
            {
                queryBuf.append(",");
            }

            queryBuf.append("?");
        }

        queryBuf.append(")");
        logCat.info(queryBuf.toString());

        return queryBuf.toString();
    }


    /**
     * returns the select part of a query
     */
    protected String getQuerySelect(Vector fieldsToSelect)
    {
        StringBuffer buf = new StringBuffer();
        int fieldsToSelectSize = fieldsToSelect.size();

        // #checkme: do i need this when using Hotspot ?
        // we scroll through vector directly (no enumeration!) to maintain correct order of elements
        for (int i = 0; i < fieldsToSelectSize; i++)
        {
            Field f = (Field) fieldsToSelect.elementAt(i);
            buf.append(f.getName());
            buf.append(", ");
        }

        buf.deleteCharAt(buf.length() - 2);

        return buf.toString();
    }


    /**
     * returns the from part of a query
     */
    protected String getQueryFrom()
    {
        return name;
    }


    /**
     * returns the from part of a insert/delete/update query
     */
    protected String getQueryToChange()
    {
        return getQueryFrom();
    }


    /**
     * returns the where part of a query
     */
    protected String getQueryWhere(FieldValue[] fvEqual, FieldValue[] fvOrder, int compareMode)
    {
        boolean firstTermExists = false;
        StringBuffer buf = new StringBuffer();

        if ((fvEqual != null) && (fvEqual.length > 0))
        {
            // check if the fieldvalues contain _search_ information
            buf.append(" ( ");

            if (fvEqual[0].getSearchMode() == DbBaseHandlerTag.SEARCHMODE_NONE)
            {
                buf.append(FieldValue.getWhereClause(fvEqual));
            }
            else
            {
                buf.append(FieldValue.getWhereEqualsSearchClause(fvEqual));
            }

            buf.append(" ) ");
            firstTermExists = true;
        }

        if ((fvOrder != null) && (fvOrder.length > 0))
        {
            if (compareMode != FieldValue.COMPARE_NONE)
            {
                buf.append(firstTermExists ? " AND ( " : "");
                buf.append(FieldValue.getWhereAfterClause(fvOrder, compareMode));
                buf.append(firstTermExists ? " ) " : "");
            }
        }

        return buf.toString();
    }


    /**
     * returns the part of the orderby-clause represented by this FieldValue object.
     * FieldName [DESC]
     * (ASC will be not printed because it is defined DEFAULT in SQL
     * if there are RDBMS which do not tolerate this please let me know; then i'll
     * change it)
     */
    protected String getQueryOrderBy(FieldValue[] fvOrder)
    {
        StringBuffer buf = new StringBuffer();

        if (fvOrder != null)
        {
            for (int i = 0; i < fvOrder.length; i++)
            {
                buf.append(fvOrder[i].getField().getName());

                if (fvOrder[i].getSortDirection() == FieldValue.ORDER_DESCENDING)
                {
                    buf.append(" DESC");
                }

                if (i < (fvOrder.length - 1))
                {
                    buf.append(",");
                }
            }
        }

        return buf.toString();
    }


    /**
     *  Prepares the Querystring for the select statement
     *  if the statement is for a sub-form (=> doConstrainedSelect),
     *  we set some place holders for correct mapping
     *
     * @param fieldsToSelect - vector of fields to be selected
     * @param fvEqual - fieldValues representing values we are looking for
     * @param fvOrder - fieldValues representing needs for order clauses
     * @param compareMode - and / or
     */
    protected String getSelectQuery(Vector fieldsToSelect, FieldValue[] fvEqual, FieldValue[] fvOrder, int compareMode)
    {
        StringBuffer buf = new StringBuffer();
        buf.append("SELECT ");
        buf.append(getQuerySelect(fieldsToSelect));
        buf.append(" FROM ");
        buf.append(getQueryFrom());

        String s;
        s = getQueryWhere(fvEqual, fvOrder, compareMode);

        if (s.length() > 0)
        {
            buf.append(" WHERE ( ");
            buf.append(s);
            buf.append(")");
        }

        s = getQueryOrderBy(fvOrder);

        if (s.length() > 0)
        {
            buf.append(" ORDER BY ");
            buf.append(s);
        }

        logCat.info("doSelect:" + buf.toString());

        return buf.toString();
    }


    /**
     *        Prepares the Querystring for the free form select statement
     *
     *        @param fieldsToSelect - vector of fields to be selected
     *  @param whereClause - free-form whereClause to be appended to query
     */
    protected String getFreeFormSelectQuery(Vector fieldsToSelect, String whereClause, String tableList)
    {
        StringBuffer buf = new StringBuffer();
        buf.append("SELECT ");
        buf.append(getQuerySelect(fieldsToSelect));
        buf.append(" FROM ");

        if (Util.isNull(tableList))
        {
            buf.append(getQueryFrom());
        }
        else
        {
            buf.append(tableList);
        }

        buf.append(" ");
        buf.append(whereClause);
        logCat.info("doFreeFromSelect:" + buf.toString());

        return buf.toString();
    }


    /**
     * DOCUMENT ME!
     *
     * @param fieldsToSelect DOCUMENT ME!
     * @param fvEqual DOCUMENT ME!
     * @param fvOrder DOCUMENT ME!
     * @param compareMode DOCUMENT ME!
     * @param maxRows DOCUMENT ME!
     * @param ps DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     *
     * @throws SQLException DOCUMENT ME!
     */
    protected ResultSet getDoSelectResultSet(Vector fieldsToSelect, FieldValue[] fvEqual, FieldValue[] fvOrder, int compareMode, int maxRows, PreparedStatement ps) throws SQLException
    {
        int curCol = 1;
        logCat.debug("###getDoSelectResultSet pos1");

        if ((fvEqual != null) && (fvEqual.length > 0))
        {
            logCat.debug("###getDoSelectResultSet pos2");
            curCol = FieldValue.populateWhereEqualsClause(fvEqual, ps, curCol);
            logCat.debug("###getDoSelectResultSet pos3");
        }

        logCat.debug("###getDoSelectResultSet pos4");

        if ((compareMode != FieldValue.COMPARE_NONE) && (fvOrder != null) && (fvOrder.length > 0))
        {
            logCat.debug("###getDoSelectResultSet pos5");
            FieldValue.populateWhereAfterClause(fvOrder, ps, curCol);
            logCat.debug("###getDoSelectResultSet pos6");
        }

        logCat.debug("###getDoSelectResultSet pos7");

        ResultSet result = null;

        try
        {
            result = ps.executeQuery();
        }
        catch (SQLException sqle)
        {
            SqlUtil.logSqlException(sqle);
            throw new SQLException(sqle.getMessage());
        }

        return result;
    }


    /**
     * DOCUMENT ME!
     *
     * @param fieldsToSelect DOCUMENT ME!
     * @param fvEqual DOCUMENT ME!
     * @param vfOrder DOCUMENT ME!
     * @param compareMode DOCUMENT ME!
     * @param maxRows DOCUMENT ME!
     * @param con DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     *
     * @throws SQLException DOCUMENT ME!
     */
    public ResultSetVector doConstrainedSelect(Vector fieldsToSelect, FieldValue[] fvEqual, FieldValue[] vfOrder, int compareMode, int maxRows, Connection con) throws SQLException
    {
        String query = getSelectQuery(fieldsToSelect, fvEqual, vfOrder, compareMode);
        PreparedStatement ps = con.prepareStatement(query);
        ps.setMaxRows(maxRows); // important when quering huge tables

        ResultSetVector result = new ResultSetVector(fieldsToSelect, getDoSelectResultSet(fieldsToSelect, fvEqual, vfOrder, compareMode, maxRows, ps));
        ps.close();
        logCat.info("rsv size=" + result.size());

        return result;
    }


    /**
     *  perform free-form select query
     *
     *  @param fieldsToSelect - vector of fields to be selected
     *  @param whereClause - free-form whereClause to be appended to query
     *  @param maxRows - how many rows should be stored in the resultSet (zero means unlimited)
     *  @param connection - the active db connection to use
     */
    public ResultSetVector doFreeFormSelect(Vector fieldsToSelect, String whereClause, String tableList, int maxRows, Connection con) throws SQLException
    {
        Statement stmt = con.createStatement();
        ResultSet rs;
        ResultSetVector result;

        String query = getFreeFormSelectQuery(fieldsToSelect, whereClause, tableList);
        stmt.setMaxRows(maxRows); // important when quering huge tables

        try
        {
            rs = stmt.executeQuery(query);
        }
        catch (SQLException sqle)
        {
            SqlUtil.logSqlException(sqle);
            throw new SQLException(sqle.getMessage());
        }

        result = new ResultSetVector(fieldsToSelect, rs);

        // 20021115-HKK: resultset is closed in ResultSetVector()
        // rs.close();
        stmt.close();
        logCat.info("rsv size=" + result.size());

        return result;
    }


    /**
     *
     * @param field
     * @param fieldValue
     * @return
     */
    private String createToken(Field field, String fieldValue)
    {
        StringBuffer buf = new StringBuffer();
        buf.append(field.getId());
        buf.append(":");
        buf.append(fieldValue.length());
        buf.append(":");
        buf.append(fieldValue);

        return buf.toString();
    }


    /**
     * builds a "position- string" representing the values of the current row in the given
     * ResultSetVector..
     *
     * not all field-values get explicitl listed in this string. only fields important
     * for navigation and sorting are listed.
     *
     * position strings are used as request parameters allowing the framework to keep track
     * of the position the user comes from or goes to.
     *
     * look into com.itp.tablib.DbFormTag for better understanding
     *
     * changed 0-04-2001 by joe
     * #note: enhanced algorithm since version 0.9!
     */
    public String getPositionString(ResultSetVector rsv)
    {
        StringBuffer buf = new StringBuffer();

        if (ResultSetVector.isEmptyOrNull(rsv))
        {
            return null;
        }

        String[] currentRow = rsv.getCurrentRow();

        if (currentRow == null)
        {
            return null;
        }

        int cnt = 0;

        for (int i = 0; i < getFields().size(); i++)
        {
            Field f = (Field) getFields().elementAt(i);

            if (f.isKey() || f.isFieldSortable())
            {
                //bugfix 30-04-2001:
                //
                //we want the "-" sign only if a token was already written out
                //
                if (cnt > 0)
                {
                    buf.append("-"); // control byte
                }

                buf.append(createToken(f, currentRow[f.getId()]));
                cnt++;
            }
        }

        return buf.toString();
    }


    /**
     * does basically the same as getPositionString but only for key-fields
     * #checkme: could be merged with getPositionString
     * #fixme: replace seperator-based tokenization by better algoithm!
     */
    public String getKeyPositionString(ResultSetVector rsv)
    {
        StringBuffer buf = new StringBuffer();

        if (ResultSetVector.isEmptyOrNull(rsv))
        {
            return null;
        }

        String[] currentRow = rsv.getCurrentRow();

        if (currentRow == null)
        {
            return null;
        }

        for (int i = 0; i < getKey().size(); i++)
        {
            Field f = (Field) getKey().elementAt(i);

            if (i > 0)
            {
                buf.append("-"); // control byte
            }

            buf.append(createToken(f, currentRow[f.getId()]));
        }

        return buf.toString();
    }


    /**
     * DOCUMENT ME!
     *
     * @param fvHT DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public String getKeyPositionString(Hashtable fvHT)
    {
        StringBuffer buf = new StringBuffer();

        for (int i = 0; i < getKey().size(); i++)
        {
            Field f = (Field) getKey().elementAt(i);
            String value = (String) fvHT.get(f);

            if (value == null)
            {
                throw new IllegalArgumentException("wrong fields provided");
            }

            if (i > 0)
            {
                buf.append("-"); // control byte
            }

            buf.append(createToken(f, value));
        }

        return buf.toString();
    }


    /**
     *  used for instance by goto with prefix
     */
    public String getPositionStringFromFieldAndValueHt(Hashtable ht)
    {
        StringBuffer buf = new StringBuffer();

        int cnt = 0;
        Enumeration enum = ht.keys();

        while (enum.hasMoreElements())
        {
            String fieldName = (String) enum.nextElement();

            Field aField = getFieldByName(fieldName);

            if (aField != null)
            {
                String fieldValue = (String) ht.get(fieldName);

                if (cnt > 0)
                {
                    buf.append('-'); // control byte
                }

                buf.append(createToken(aField, fieldValue));
                cnt++;
            }
            else
            {
                logCat.error("provided goto field " + fieldName + " not found!");
            }
        }

        return buf.toString();
    }


    /**
     * this method parses a position string and build a data structure
     * representing the values of the fields decoded from the position.
     *
     * #fixme: replace seperator-based tokenization by better algoithm!
     */
    public Hashtable getFieldValuesFromPositionAsHt(String position)
    {
        // 20020705-HKK: Position maybe string with length = 0!!!!
        if ((position == null) || (position.length() == 0))
        {
            return null;
        }

        // trailing blanks are significant for CHAR database fields
        //	position = position.trim();
        Hashtable result = new Hashtable();

        int startIndex = 0;
        boolean endOfString = false;

        // looping through the string
        while (!endOfString)
        {
            int firstColon = position.indexOf(':', startIndex);
            int secondColon = position.indexOf(':', firstColon + 1);

            String fieldIdStr = position.substring(startIndex, firstColon);
            int fieldId = Integer.parseInt(fieldIdStr);

            String valueLengthStr = position.substring(firstColon + 1, secondColon);
            int valueLength = Integer.parseInt(valueLengthStr);

            int controlIndex = secondColon + 1 + valueLength;

            // make already be trimmed ... avoid substring exception
            String valueStr = (controlIndex < position.length()) ? position.substring(secondColon + 1, controlIndex) : position.substring(secondColon + 1);

            FieldValue fv = new FieldValue();
            fv.setField(getField(fieldId));
            fv.setFieldValue(valueStr);

            result.put(new Integer(fieldId), fv);

            if (controlIndex == position.length())
            {
                endOfString = true;
            }
            else if (controlIndex > position.length())
            {
                logCat.warn("Controlbyte wrong but continuing execution");
                endOfString = true;
            }
            else
            {
                char controlByte = position.charAt(controlIndex);

                if (controlByte != '-')
                {
                    logCat.error("Controlbyte wrong, abandon execution");
                    throw new IllegalArgumentException();
                }

                startIndex = controlIndex + 1;

                if (position.length() == startIndex)
                {
                    endOfString = true;
                }
            }
        }

        return result;
    }


    /**
     *  in version 0.9 this method moved from FieldValue.fillWithValues to Table.fillWithValues
     */
    public void fillWithValues(FieldValue[] orderConstraint, String aPosition)
    {
        Hashtable ht = getFieldValuesFromPositionAsHt(aPosition);

        // 20021104-HKK: Error handling if aPosition is not given!
        if (ht != null)
        {
            logCat.info("*** parsing through: " + aPosition);

            // then we copy some of those values into the orderConstraint
            for (int i = 0; i < orderConstraint.length; i++)
            {
                Field f = orderConstraint[i].getField();

                if (f != null)
                {
                    logCat.info("***" + f.getId() + "***");

                    Integer aFieldId = new Integer(f.getId());
                    FieldValue aFieldValue = (FieldValue) ht.get(aFieldId);

                    if (aFieldValue != null)
                    {
                        orderConstraint[i].setFieldValue(aFieldValue.getFieldValue());
                    }
                    else
                    {
                        logCat.warn("position entry has null value:" + f.getName());
                    }
                }
            }
        }
    }


    // ----------------- some convenience methods ---------------------------------------------

    /**
     * generates a part of the SQL where clause needed to select a distinguished row form the table
     * this is done by querying for KEY VALUES !
     */
    public String getWhereClauseForPS()
    {
        StringBuffer buf = new StringBuffer();
        int cnt = this.getKey().size();

        for (int i = 0; i < cnt; i++)
        {
            Field keyField = (Field) this.getKey().elementAt(i);

            // get the name of the encoded key field
            buf.append(keyField.getName());
            buf.append(" = ?");

            if (i < (cnt - 1))
            {
                buf.append(" AND ");
            }
        }

        return buf.toString();
    }


    /**
     * POPULATES a part of the SQL where clause needed to select a distinguished row form the table
     * using values endcoded in a string
     * #fixme: replace seperator-based tokenization by better algoithm!
    */
    public void populateWhereClauseForPS(String keyValuesStr, PreparedStatement ps, int startColumn) throws SQLException
    {
        int col = startColumn;

        // then we list the values of the key-fields, so that the WHERE clause matches the right dataset
        Hashtable keyValuesHt = getFieldValuesFromPositionAsHt(keyValuesStr);

        int keyLength = this.getKey().size();

        for (int i = 0; i < keyLength; i++)
        {
            Field curField = (Field) this.getKey().elementAt(i);

            FieldValue aFieldValue = (FieldValue) keyValuesHt.get(new Integer(curField.getId()));
            String valueStr = aFieldValue.getFieldValue();

            SqlUtil.fillPreparedStatement(ps, col, valueStr, curField.getType());
            col++;
        }
    }


    /**********************************************************
     * Grunikiewicz.philip@hydro.qc.ca
     * 2001-08-09
     *
     * The orderBy clause usually defaults to ASCending order.
     * A user may add, if we/she wishes the keyword ASC (ascending)
     * or DESC (descending) to specify a particular direction.
     * Code in this method parses the orderBy clause and finds an occurence
     * of either ASC or DESC.  Suppose your field name is DESCRIPTION!
     * This name contains DESC therefore causing unexpected behaviour.
     * This bug fix consists of fine-tunning the parsing function to take into
     * consideration the sequence of parameters: 1-Field 2-Command
     *
     ***********************************************************/
    private Vector createOrderFVFromAttribute(String order)
    {
        Vector result = new Vector();

        if (order != null)
        {
            StringTokenizer st = new StringTokenizer(order, ",");

            while (st.hasMoreTokens())
            {
                //Remove leading and trailing white space characters.
                String token = st.nextToken().trim();
                logCat.info("token = " + token);

                FieldValue fv = new FieldValue();
                boolean sortDirection = FieldValue.ORDER_ASCENDING; // we propose the default

                //Separate field from command
                int index = token.indexOf(" "); // Blank space used between field and command

                if (index != -1) // Do we have a command, if not assume ASC order
                {
                    String command = token.substring(index);
                    int pos = command.indexOf("ASC");

                    if (pos == -1) // ASC not found, try descending
                    {
                        pos = command.indexOf("DESC");

                        if (index != -1)
                        {
                            sortDirection = FieldValue.ORDER_DESCENDING; // ... we set DESC.
                        }
                    }
                }

                String fieldName;

                if (index == -1)
                {
                    fieldName = token.trim();
                }
                else
                {
                    fieldName = token.substring(0, index).trim();
                }

                Field f = this.getFieldByName(fieldName);

                if (f != null)
                {
                    fv.setField(f);
                    fv.setSortDirection(sortDirection);
                    logCat.info("Field '" + fieldName + "' is ordered in mode:" + sortDirection);
                    result.addElement(fv);
                }
            }
        }

        return result;
    }


    private Vector createOrderFVFromRequest(HttpServletRequest request, String paramStub, Vector sortFields)
    {
        Vector result = new Vector();
        int fieldIndex = paramStub.length() + 1;

        // "sort_1" -> fieldindex= 8 (length of paramStub "order_1" is 7)
        for (int i = 0; i < sortFields.size(); i++)
        {
            String dataParam = (String) sortFields.elementAt(i);
            int fieldId = Integer.parseInt(dataParam.substring(fieldIndex));
            String sortState = ParseUtil.getParameter(request, dataParam);
            logCat.info("### dataparam=" + dataParam);
            logCat.info("### fieldId=" + fieldId);
            logCat.info("### sortState=" + sortState);

            if (sortState.equalsIgnoreCase("asc") || sortState.equalsIgnoreCase("desc"))
            {
                boolean sortDirection = sortState.equalsIgnoreCase("asc") ? FieldValue.ORDER_ASCENDING : FieldValue.ORDER_DESCENDING;
                FieldValue fv = new FieldValue();
                fv.setField(this.getField(fieldId));
                fv.setSortDirection(sortDirection);
                result.addElement(fv);
            }
        }

        return result;
    }


    /**
      *  Column ["ASC" | "DESC"] {"," Column ["ASC" | "DESC"] }
      *  (if neither ASC nor DESC follow "Col", then ASC is choosen as default)
      *
      *  this method assures, that ALL KEY FIELDs are part of the order criteria,
      *  in any case (independly from the order-Str). if necessary it appends them.
      *  WHY: to ensure correct scrollig (not getting STUCK if the search criteria
      *  are not "sharp" enough)
      * #fixme - better explaination
      * #fixme - determinate illegal input and throw IllegalArgumentException
      *
      * @param order - a String from JSP provided by the user in SQL-Style:
      */
    public FieldValue[] createOrderFieldValues(String order, HttpServletRequest request, boolean includeKeys)
    {
        Vector result = null;

        if (request != null)
        {
            String paramStub = "sort_" + this.getId();
            Vector sortFields = ParseUtil.getParametersStartingWith(request, paramStub);

            if (sortFields.size() > 0)
            {
                result = createOrderFVFromRequest(request, paramStub, sortFields);
            }
        }

        // 20020703-HKK: use the default order if result.size == 0, not only if result == null
        //               This happens if  all parameters with sort_  are set to none
        if (((result == null) || result.isEmpty()))
        {
            // 20021104-HKK: use default order from table if form has no order!
            if (order == null)
            {
                order = getOrderBy();
            }

            result = createOrderFVFromAttribute(order);

            logCat.debug("@@@ 1");

            for (int i = 0; i < result.size(); i++)
            {
                FieldValue fieldVal = (FieldValue) result.elementAt(i);
                logCat.debug("fieldValue " + fieldVal.toString());
            }
        }

        if ((result == null) && !includeKeys)
        {
            return null; // then we've got definitely no over
        }

        // scroll through keys and append to order criteria, if not already included
        for (int i = 0; i < this.getKey().size(); i++)
        {
            Field keyField = (Field) getKey().elementAt(i);
            boolean found = false;
            int j = 0;

            while (!found && (j < result.size()))
            {
                FieldValue fv = (FieldValue) result.elementAt(j);

                if (fv.getField() == keyField)
                {
                    found = true;
                }

                j++;
            }

            if (!found)
            {
                addFieldValue(result, keyField);
            }
        }

        FieldValue[] resultArray = new FieldValue[result.size()];
        result.copyInto(resultArray);
        logCat.debug("@@@ 2");

        for (int i = 0; i < resultArray.length; i++)
        {
            logCat.debug("fieldValue " + resultArray[i].toString());
        }

        return resultArray;
    }


    //------------------------------ utility / helper methods ---------------------------------

    /**
     * for logging / debugging purposes only
     */
    public String traverse()
    {
        StringBuffer buf = new StringBuffer();
        buf.append("\nname=");
        buf.append(name);
        buf.append(" ");

        for (int i = 0; i < getFields().size(); i++)
        {
            Field f = (Field) getFields().elementAt(i);
            buf.append("\nfield: ");
            buf.append(f.toString());
        }

        return buf.toString();
    }


    // helper method used locally in this class
    private void addFieldValue(Vector stub, Field f)
    {
        FieldValue fv = new FieldValue();
        fv.setField(f);
        stub.addElement(fv);
    }


    /**
     *  transfer values from asscociative (name-orientated, user friendly) hashtable [param 'assocFv']
     *  into hashtable used interally by DbForms used during parameter-passing for interceptors
     */
    public void synchronizeData(Hashtable fv, Hashtable assocFv)
    {
        /*
            this (old) piece of code copies only fields which are in both hashtables

                            Enumeration enum = fv.keys();
                            while(enum.hasMoreElements()) {
                                    Integer ii = (Integer) enum.nextElement();
                                    Field f = this.getField(ii.intValue());
                                    String newValue = (String) assocFv.get(f.getName());

                                    if(newValue!=null)
                                            fv.put(ii, newValue);
                            }
        */

        // this (new) piece of code copies all fields which are in assoc.-hashtable
        Enumeration enum = assocFv.keys();

        while (enum.hasMoreElements())
        {
            String aFieldName = (String) enum.nextElement();
            Field f = this.getFieldByName(aFieldName);

            if (f != null)
            {
                Integer ii = new Integer(f.getId());
                String newValue = (String) assocFv.get(aFieldName);

                if (newValue != null)
                {
                    fv.put(ii, newValue);
                }
            }
        }
    }


    /**
     * DOCUMENT ME!
     *
     * @param action DOCUMENT ME!
     * @param request DOCUMENT ME!
     * @param associativeArray DOCUMENT ME!
     * @param config DOCUMENT ME!
     * @param con DOCUMENT ME!
     *
     * @throws SQLException DOCUMENT ME!
     * @throws MultipleValidationException DOCUMENT ME!
     */
    public void processInterceptors(int action, HttpServletRequest request, Hashtable associativeArray, DbFormsConfig config, Connection con) throws SQLException, MultipleValidationException
    {
        try
        {
            int interceptorsCnt = interceptors.size();

            for (int i = 0; i < interceptorsCnt; i++)
            {
                Interceptor interceptor = (Interceptor) interceptors.elementAt(i);
                Class interceptorClass = Class.forName(interceptor.getClassName());
                DbEventInterceptor dbi = (DbEventInterceptor) interceptorClass.newInstance();

                if (action == DbEventInterceptor.PRE_INSERT)
                {
                    if (dbi.preInsert(request, associativeArray, config, con) == DbEventInterceptor.DENY_OPERATION)
                    {
                        throw new SQLException("Sorry, adding data to table " + this.getName() + " was not granted this time. Your request violated a condition.");
                    }
                }
                else if (action == DbEventInterceptor.POST_INSERT)
                {
                    dbi.postInsert(request, config, con);
                }
                else if (action == DbEventInterceptor.PRE_UPDATE)
                {
                    if (dbi.preUpdate(request, associativeArray, config, con) == DbEventInterceptor.DENY_OPERATION)
                    {
                        throw new SQLException("Sorry, updating data in table " + this.getName() + " was not granted this time. Your request violated a condition.");
                    }
                }
                else if (action == DbEventInterceptor.POST_UPDATE)
                {
                    dbi.postUpdate(request, config, con);
                }
                else if (action == DbEventInterceptor.PRE_DELETE)
                {
                    if (dbi.preDelete(request, associativeArray, config, con) == DbEventInterceptor.DENY_OPERATION)
                    {
                        throw new SQLException("Sorry, deleting data from table " + this.getName() + " was not granted this time. Your request violated a condition.");
                    }
                }
                else if (action == DbEventInterceptor.POST_DELETE)
                {
                    dbi.postDelete(request, config, con);
                }
                else if (action == DbEventInterceptor.PRE_SELECT)
                {
                    if (dbi.preSelect(request, config, con) == DbEventInterceptor.DENY_OPERATION)
                    {
                        throw new SQLException("Sorry, selecting data from table " + this.getName() + " was not granted this time. Your request violated a condition.");
                    }
                }
                else if (action == DbEventInterceptor.POST_SELECT)
                {
                    dbi.postSelect(request, config, con);
                }
            }

            // PG = 2001-12-04
            // No need to add extra comments, just re-throw exceptions as SqlExceptions
        }
        catch (ClassNotFoundException cnfe)
        {
            logCat.warn(" ClassNotFoundException : " + cnfe.getMessage());
            throw new SQLException(cnfe.getMessage());
        }
        catch (InstantiationException ie)
        {
            logCat.warn(" InstantiationException : " + ie.getMessage());
            throw new SQLException(ie.getMessage());
        }
        catch (IllegalAccessException iae)
        {
            logCat.warn(" IllegalAccessException : " + iae.getMessage());
            throw new SQLException(iae.getMessage());
        }
        catch (SQLException sqle)
        {
            throw new SQLException(sqle.getMessage());
        }
        catch (MultipleValidationException mve)
        {
            throw new MultipleValidationException(mve.getMessages());
        }
        catch (ValidationException ve)
        {
            throw new SQLException(ve.getMessage());
        }
    }


    /**
     * We have the field ID - we need the field name
     */
    public String getFieldName(int fieldID)
    {
        Field f = (Field) getFields().elementAt(fieldID);

        return (f.getName());
    }


    /**
     * returns the hash table. Moved from dbFormTag to table, so that you can overload it!
     */
    public Hashtable getNamesHashtable(String core)
    {
        Hashtable result = new Hashtable();
        Enumeration enum = getFields().elements();

        while (enum.hasMoreElements())
        {
            Field f = (Field) enum.nextElement();
            String fieldName = f.getName();
            int fieldId = f.getId();
            StringBuffer sb = new StringBuffer(core);
            sb.append("_");
            sb.append(getId());
            sb.append("_");
            sb.append(fieldId);
            result.put(fieldName, sb.toString());

            // in PHP slang we would call that an "associative array" :=)
        }

        return result;
    }


    /**
     * Getter for property defaultVisibleFields.
     *
     * @return Value of property defaultVisibleFields.
     */
    public String getDefaultVisibleFields()
    {
        return this.defaultVisibleFields;
    }


    /**
     * Setter for property defaultVisibleFields.
     *
     * @param defaultVisibleFields New value of property defaultVisibleFields.
     */
    public void setDefaultVisibleFields(String defaultVisibleFields)
    {
        this.defaultVisibleFields = defaultVisibleFields;
    }


    /**
     *  used for instance by gotoEvent
     */
    public String getPositionString(FieldValue[] fv)
    {
        StringBuffer buf = new StringBuffer();

        for (int i = 0; i < fv.length; i++)
        {
            Field f = fv[i].getField();
            String value = fv[i].getFieldValue();

            if (value == null)
            {
                throw new IllegalArgumentException("wrong fields provided");
            }

            if (i > 0)
            {
                buf.append("-"); // control byte
            }

            buf.append(createToken(f, value));
        }

        return buf.toString();
    }


    /**
     * DOCUMENT ME!
     *
     * @param parentTable DOCUMENT ME!
     * @param parentFieldString DOCUMENT ME!
     * @param childFieldString DOCUMENT ME!
     * @param aPosition DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public FieldValue[] mapChildFieldValues(Table parentTable, String parentFieldString, String childFieldString, String aPosition)
    {
        // 1 to n fields may be mapped
        Vector childFieldNames = ParseUtil.splitString(childFieldString, ",;~");
        Vector parentFieldNames = ParseUtil.splitString(parentFieldString, ",;~");

        // do some basic checks
        // deeper checks like Datatyp-compatibility,etc not done yet
        int len = childFieldNames.size();

        if ((len == 0) || (len != parentFieldNames.size()))
        {
            return null;
        }

        Hashtable ht = parentTable.getFieldValuesFromPositionAsHt(aPosition);
        FieldValue[] childFieldValues = new FieldValue[len];

        for (int i = 0; i < len; i++)
        {
            String parentFieldName = (String) parentFieldNames.elementAt(i);
            Field parentField = parentTable.getFieldByName(parentFieldName);
            String childFieldName = (String) childFieldNames.elementAt(i);
            Field childField = this.getFieldByName(childFieldName);
            FieldValue aFieldValue = (FieldValue) ht.get(new Integer(parentField.getId()));

            if (aFieldValue == null)
            {
                throw new IllegalArgumentException("ERROR: Make sure that field " + parentField.getName() + " is a KEY of the table " + this.getName() + "! Otherwise you can not use it as PARENT/CHILD LINK argument!");
            }

            String currentParentFieldValue = aFieldValue.getFieldValue();
            childFieldValues[i] = new FieldValue(childField, currentParentFieldValue, true);
        }

        return childFieldValues;
    }
}
