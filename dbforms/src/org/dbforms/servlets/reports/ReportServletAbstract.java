/*
 * $Header$
 * $Revision$
 * $Date$
 *
 * DbForms - a Rapid Application Development Framework
 * Copyright (C) 2001 Joachim Peer <joepeer@excite.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */

package org.dbforms.servlets.reports;


import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.dbforms.config.DbFormsConfig;
import org.dbforms.config.DbFormsConfigRegistry;
import org.dbforms.config.ResultSetVector;
import org.dbforms.config.Table;

import org.dbforms.event.WebEvent;

import org.dbforms.taglib.DbFormTag;

import org.dbforms.util.MessageResourcesInternal;
import org.dbforms.util.PageContextBuffer;
import org.dbforms.util.ParseUtil;
import org.dbforms.util.Util;
import org.dbforms.util.external.FileUtil;

import java.io.IOException;
import java.io.PrintWriter;

import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.PageContext;

/**
 * This is the abstract base class for generating reports.
 * 
 * @author Henner Kollmann
 */
public abstract class ReportServletAbstract extends HttpServlet {

	private static Log logCat = LogFactory.getLog(ReportServletAbstract.class
			.getName());

	private static final String REPORTCONFIGDIR = "reportdirs";

	private String[] reportdirs;

	/**
	 * Basic servlet method, answers requests from the browser.
	 * 
	 * @param request
	 *            HTTPServletRequest
	 * @param response
	 *            HTTPServletResponse
	 * 
	 * @throws ServletException
	 *             if there is a servlet problem.
	 * @throws IOException
	 *             if there is an I/O problem.
	 */
	public final void doGet(HttpServletRequest request,
			HttpServletResponse response) throws ServletException, IOException {
		process(request, response);
	}

	/**
	 * Basic servlet method, answers requests fromt the browser.
	 * 
	 * @param request
	 *            HTTPServletRequest
	 * @param response
	 *            HTTPServletResponse
	 * 
	 * @throws ServletException
	 *             if there is a servlet problem.
	 * @throws IOException
	 *             if there is an I/O problem.
	 */
	public final void doPost(HttpServletRequest request,
			HttpServletResponse response) throws ServletException, IOException {
		process(request, response);
	}

	/**
	 * Initialize this servlet.
	 * 
	 * @exception ServletException
	 *                if we cannot configure ourselves correctly
	 */
	public void init() throws ServletException {
		String value = getServletConfig().getInitParameter(REPORTCONFIGDIR);
		if (value == null) {
			value = "WEB-INF/reports/";
		}
		reportdirs = StringUtils.split(value, ',');
	}

	/**
	 * generates a report.
	 * 
	 * @param reportFileFullName
	 *            filename of report to process reportHTTPServletRequest
	 *            generated by getReportFile! getReportFile should be called
	 *            before fetching data, so that error handling of report not
	 *            found e.g. could be processed first!
	 * @param dataSource
	 *            data for the report
	 * @param context
	 *            ServletContext
	 * @param request
	 *            HTTPServletRequest
	 * @param response
	 *            HTTPServletResponse
	 */
	protected abstract ReportWriter processReport(String reportFileFullName,
			JRDataSourceAbstract dataSource, ServletContext context,
			HttpServletRequest request, HttpServletResponse response);

	protected abstract String getReportFileExtension();

	protected final void handleException(HttpServletRequest request,
			HttpServletResponse response, Exception e) {
		sendErrorMessage(request, response, MessageResourcesInternal
				.getMessage("dbforms.reports.exception", request.getLocale(),
						new String[] { e.getMessage() }));
	}

	private final void handleNoData(HttpServletRequest request,
			HttpServletResponse response) {
		sendErrorMessage(request, response, MessageResourcesInternal
				.getMessage("dbforms.reports.nodata", request.getLocale()));
	}

	private final void sendErrorMessage(HttpServletRequest request,
			HttpServletResponse response, String message) {
		try {
			Vector errors = (Vector) request.getAttribute("errors");
			errors.add(new Exception(message));

			String fue = ParseUtil.getParameter(request, "source");
			String contextPath = request.getContextPath();

			if (!Util.isNull(fue)) {
				fue = fue.substring(contextPath.length());
			}

			if (Util.isNull(fue)) {
				sendErrorMessageText(response, message);
			} else {
				request.getRequestDispatcher(fue).forward(request, response);
			}
		} catch (Exception ex) {
			logCat.error("sendErrorMessage", ex);
			sendErrorMessageText(response, message);
		}
	}

	protected void compileReport(ServletContext context,
			String reportFile) throws Exception {
	};

	/**
	 * generates a report from request. Tries to get data from DbForms.
	 * 
	 * @param request
	 *            HTTPServletRequest
	 * @param response
	 *            HTTPServletResponse
	 */
	protected void process(HttpServletRequest request,
			HttpServletResponse response) {
		// create report name
		try {
			String reportFile = getReportFileFullName(request.getPathInfo(),
					getServletContext(), request, response);

			if (!Util.isNull(reportFile)) {
				compileReport(getServletContext(), reportFile);
				JRDataSourceAbstract dataSource = getDataForReport(request, response);
				if (!response.isCommitted()) {
					if (dataSource == null) {
						handleNoData(request, response);
					} else {
						ReportWriter res = processReport(reportFile,
								dataSource, getServletContext(), request,
								response);
						if (!response.isCommitted()) {
							if (res == null) {
								handleNoOutput(request, response);
							} else {
								processOutput(res, request, response);
							}
						}
					}
				}
			} 
		} catch (Exception e) {
			logCat.error("process", e);
			handleException(request, response, e);
		}
	}

	private void processOutput(ReportWriter out, HttpServletRequest request,
			HttpServletResponse response) throws Exception {
		if ((out.data == null) && (out.data.size() == 0)) {
			handleNoOutput(request, response);
			return;
		}
		response.setHeader("Expires", "0");
		response.setHeader("Cache-Control",
				"must-revalidate, post-check=0, pre-check=0");
		response.setHeader("Pragma", "public");
		if (!Util.isNull(out.fileName)) {
			response.setHeader("Content-disposition", "inline; filename="
					+ out.fileName);
		}
		if (!Util.isNull(out.mimeType)) {
			response.setContentType(out.mimeType);
		}
		// Send the output stream to the client
		response.setContentLength(out.data.size());
		ServletOutputStream outputStream = response.getOutputStream();
		try {
			out.data.writeTo(outputStream);
			outputStream.flush();
		} finally {
			outputStream.close();
		}
	}

	private String getReportFileFullName(String reportFileName,
			ServletContext context, HttpServletRequest request,
			HttpServletResponse response) {
		String reportFile = null;
		
		try {
			boolean found = false;
			for (int i = 0; i < reportdirs.length; i++) {
				reportFile = context
						.getRealPath(reportdirs[i] + reportFileName) ;
				String testName = reportFile  + getReportFileExtension();
				if (FileUtil.fileExists(testName)) {
					found = true;
					break;
				}
			}
			if (!found) {
				handleNoReport(request, response);
				reportFile = null;
			}
		} catch (Exception e) {
			handleException(request, response, e);
		}

		return reportFile;
	}

	private void handleNoReport(HttpServletRequest request,
			HttpServletResponse response) {
		sendErrorMessage(request, response, MessageResourcesInternal
				.getMessage("dbforms.reports.noreport", request.getLocale(),
						new String[] { request.getPathInfo() }));
	}

	/**
	 * get a JRDataSource for report data. Source can be a Collection, an rsv,
	 * or dbform if session variable "jasper.input" is set, it must point to a
	 * Collection object if session variable "jasper.rsv" is set, it must point
	 * to a ResultSetVector object otherwise the enclosing dbform is used for
	 * data
	 * 
	 * @param context
	 * @param request
	 * @param response
	 * 
	 * @return
	 */
	private JRDataSourceAbstract getDataForReport(HttpServletRequest request, HttpServletResponse response) {
		JRDataSourceAbstract dataSource = null;
		Table table = null;
		ResultSetVector rsv = null;

		try {
			// is the datasource a Collection ?
			Object input = request.getAttribute("jasper.input");
			if (input == null)
				input = request.getSession().getAttribute("jasper.input");
			if ((input != null) && (input instanceof Collection)) {
				Iterator iter = ((Collection) input).iterator();
				dataSource = new JRDataSourceIter(iter);
				return dataSource;
			}

			// check if we are using a ResultSetVector passed by user
			rsv = (ResultSetVector) request.getAttribute("jasper.rsv");
			if (rsv == null)
				rsv = (ResultSetVector) request.getSession().getAttribute("jasper.rsv");
			if (rsv != null) {
				logCat.info("get resultsetvector rsv= " + rsv.size());
				if (rsv.size() == 0) {
					handleNoData(request, response);
				} else {
					dataSource = new JRDataSourceRSV(rsv);
				}
				return dataSource;
			}

			PageContext pageContext = new PageContextBuffer();
			pageContext
					.initialize(this, request, response, null, true, 0, true);

			// Create form to get the resultsetvector
			WebEvent webEvent = (WebEvent) request.getAttribute("webEvent");
			table = webEvent.getTable();

			if (table == null) {
				logCat.error("table==null");
			}

			if ((webEvent != null) && (table != null) && (table.getId() != -1)) {
				// Generate DataSource for JasperReports from call to DbForm
				DbFormsConfig config = null;

				try {
					config = DbFormsConfigRegistry.instance().lookup();
				} catch (Exception e) {
					logCat.error(e);
					throw new ServletException(e);
				}

				String tableName = config.getTable(webEvent.getTable().getId())
						.getName();

				// Simulate call to DbFormTag to get resultsetvector
				DbFormTag form = new DbFormTag();
				form.setPageContext(pageContext);
				form.setTableName(tableName);

				String maxRows = ParseUtil
						.getParameter(request, "MaxRows", "*");
				form.setMaxRows(maxRows);
				form.setFollowUp("");
				form.setAutoUpdate("false");

				// set the source attribute to the requestURI.
				// So the form will think that the source is equal to the target
				// and will use order constraints
				// Source must be saved and restored - we need it e.g. in error
				// processing again!
				String saveSource = (String) request.getAttribute("source");
				String refSource = request.getRequestURI();

				if (request.getQueryString() != null) {
					refSource += ("?" + request.getQueryString());
				}

				request.setAttribute("source", refSource);
				form.doStartTag();
				request.setAttribute("source", saveSource);

				rsv = form.getResultSetVector();
				logCat.info("get resultsetvector rsv= " + rsv.size());

				if (rsv.size() == 0) {
					handleNoData(request, response);
				} else {
					dataSource = new JRDataSourceRSV(rsv);
				}

				form.doFinally();
			}
		} catch (Exception e) {
			logCat.error(e);
		}

		return dataSource;
	}

	private void sendErrorMessageText(HttpServletResponse response,
			String message) {
		try {
			PrintWriter out = response.getWriter();
			response.setContentType("text/html");
			out.println("<html><body><h1>ERROR</h1><p>");
			out.println(message);
			out.println("</p></body></html>");
			out.flush();
			out.close();
		} catch (IOException ioe2) {
			logCat.error("sendErrorMessageText", ioe2);
		}
	}

	private void handleNoOutput(HttpServletRequest request,
			HttpServletResponse response) {
		sendErrorMessage(request, response, MessageResourcesInternal
				.getMessage("dbforms.reports.nooutput", request.getLocale()));
	}

}